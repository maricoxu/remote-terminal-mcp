diff --git a/bin/cli.js b/bin/cli.js
index 1ac5796..9197c2a 100755
--- a/bin/cli.js
+++ b/bin/cli.js
@@ -273,6 +273,13 @@ Documentation: https://github.com/maricoxu/remote-terminal-mcp
     }
 
     run() {
+        // å¦‚æœæ˜¯é€šè¿‡MCPï¼ˆéTTYç¯å¢ƒï¼‰è°ƒç”¨ï¼Œåˆ™ç›´æ¥å¯åŠ¨æœåŠ¡
+        const isMCPCall = !process.stdin.isTTY;
+        if (isMCPCall) {
+            this.start();
+            return;
+        }
+
         const args = process.argv.slice(2);
         const command = args[0];
 
@@ -296,7 +303,8 @@ Documentation: https://github.com/maricoxu/remote-terminal-mcp
                 break;
             default:
                 if (!command) {
-                    this.start(); // Default start MCP server
+                    // å¯¹äºäº¤äº’å¼CLIï¼Œæ²¡æœ‰å‘½ä»¤æ—¶æ˜¾ç¤ºå¸®åŠ©
+                    this.showHelp();
                 } else {
                     this.log(`Unknown command: ${command}`, 'error');
                     this.showHelp();
diff --git a/debugging_fixes.patch b/debugging_fixes.patch
index 5efd449..e69de29 100644
--- a/debugging_fixes.patch
+++ b/debugging_fixes.patch
@@ -1,484 +0,0 @@
-diff --git a/index.js b/index.js
-old mode 100644
-new mode 100755
-index 6438c59..6936d9b
---- a/index.js
-+++ b/index.js
-@@ -88,6 +88,7 @@ Examples:
-         if (this.args.isDebugMode || process.env.MCP_DEBUG) {
-             env.MCP_DEBUG = '1';
-         }
-+        env.REMOTE_TERMINAL_MCP_ROOT = this.packageDir;
- 
-         // å¯åŠ¨Python MCPæœåŠ¡å™¨
-         const mcp = spawn('python3', [pythonScript], {
-@@ -99,17 +100,26 @@ Examples:
-         process.stdin.pipe(mcp.stdin);
-         mcp.stdout.pipe(process.stdout);
- 
--        // å¤„ç†è¿›ç¨‹äº‹ä»¶
--        mcp.on('close', (code) => {
-+        // å¢å¼ºæ—¥å¿—ï¼šç›‘æ§çˆ¶è¿›ç¨‹stdinå…³é—­äº‹ä»¶
-+        process.stdin.on('close', () => {
-             if (this.args.isDebugMode) {
--                console.error(`MCP server exited with code: ${code}`);
-+                console.error('[DIAGNOSTIC] Parent process stdin stream has been closed.');
-             }
--            process.exit(code);
-         });
- 
-+        // å¢å¼ºæ—¥å¿—ï¼šå¤„ç†å­è¿›ç¨‹é€€å‡ºäº‹ä»¶
-+        mcp.on('close', (code, signal) => {
-+            if (this.args.isDebugMode) {
-+                console.error(`[DIAGNOSTIC] Child process exited. Code: ${code}, Signal: ${signal}`);
-+            }
-+            // ä¿æŒåŸæœ‰é€»è¾‘ï¼Œçˆ¶è¿›ç¨‹éšå­è¿›ç¨‹é€€å‡º
-+            process.exit(code === null ? 1 : code);
-+        });
-+
-+        // å¢å¼ºæ—¥å¿—ï¼šå¤„ç†å­è¿›ç¨‹é”™è¯¯äº‹ä»¶
-         mcp.on('error', (error) => {
-             if (this.args.isDebugMode) {
--                console.error('MCP server error:', error.message);
-+                console.error('[DIAGNOSTIC] Child process error event:', error.message);
-             }
-             process.exit(1);
-         });
-diff --git a/lib/config-manager.js b/lib/config-manager.js
-index 996913b..0045146 100644
---- a/lib/config-manager.js
-+++ b/lib/config-manager.js
-@@ -10,7 +10,7 @@ const chalk = require('chalk');
-  */
- class ConfigManager {
-     constructor() {
--        this.configDir = path.join(os.homedir(), '.cursor-bridge');
-+        this.configDir = path.join(os.homedir(), '.remote-terminal-mcp');
-         this.configFile = path.join(this.configDir, 'config.yaml');
-         this.serversConfigFile = path.join(this.configDir, 'servers.yaml');
-     }
-diff --git a/package.json b/package.json
-index ac1be9a..d066706 100644
---- a/package.json
-+++ b/package.json
-@@ -4,7 +4,7 @@
-   "description": "Remote Terminal MCP Server - æ™ºèƒ½script-basedè¿æ¥ç³»ç»Ÿï¼Œå®Œæ•´é›†æˆconnect_cpu_221.shé€»è¾‘",
-   "main": "index.js",
-   "bin": {
--    "remote-terminal-mcp": "bin/cli.js"
-+    "remote-terminal-mcp": "index.js"
-   },
-   "scripts": {
-     "start": "node index.js",
-@@ -14,9 +14,9 @@
-     "prepublishOnly": "npm test"
-   },
-   "keywords": [
--    "mcp",
--    "remote",
--    "terminal",
-+    "mcp", 
-+    "remote", 
-+    "terminal", 
-     "cursor",
-     "claude",
-     "script-based",
-diff --git a/python/mcp_server.py b/python/mcp_server.py
-index 06aa391..6147df2 100644
---- a/python/mcp_server.py
-+++ b/python/mcp_server.py
-@@ -12,6 +12,8 @@ import os
- import subprocess
- import time
- from pathlib import Path
-+import atexit
-+import traceback
- 
- # æ·»åŠ å½“å‰ç›®å½•åˆ°Pythonè·¯å¾„
- sys.path.append(str(Path(__file__).parent))
-@@ -499,8 +501,6 @@ async def handle_request(request):
-                 if default_server:
-                     result_text += f"ğŸŒŸ Default server: {default_server}\n"
-                 
--                result_text += "\nğŸ’¡ Use 'test_server_connection' to test connection status"
--                
-                 return create_success_response(request_id, result_text)
-                 
-             except Exception as e:
-@@ -515,30 +515,18 @@ async def handle_request(request):
-                 
-                 manager = get_ssh_manager()
-                 if not manager:
--                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-+                    return create_error_response(request_id, "SSH manager initialization failed")
-                 
--                success, message = manager.test_connection(server_name)
-+                success, msg = manager.test_connection(server_name)
-                 
-                 if success:
--                    result_text = f"âœ… Server connection test successful\n\n"
--                    result_text += f"ğŸ–¥ï¸ Server: {server_name}\n"
--                    result_text += f"ğŸ“¶ Status: {message}\n"
--                    result_text += f"ğŸ”— Connection normal, can execute remote commands"
-+                    return create_success_response(request_id, f"âœ… Server {server_name} connection successful: {msg}")
-                 else:
--                    result_text = f"âŒ Serverè¿æ¥æµ‹è¯•å¤±è´¥\n\n"
--                    result_text += f"ğŸ–¥ï¸ Server: {server_name}\n"
--                    result_text += f"âš ï¸ Error: {message}\n"
--                    result_text += f"\nğŸ’¡ Please check:\n"
--                    result_text += f"   â€¢ ServerAddresså’Œç«¯å£\n"
--                    result_text += f"   â€¢ SSH key configuration\n"
--                    result_text += f"   â€¢ Network connection\n"
--                    result_text += f"   â€¢ Serveræ˜¯å¦Online"
--                
--                return create_success_response(request_id, result_text)
--                
-+                    return create_error_response(request_id, f"âŒ Server {server_name} connection failed: {msg}")
-+                    
-             except Exception as e:
-                 debug_log(f"Error in test_server_connection: {e}")
--                return create_error_response(request_id, f"æµ‹è¯•Serverè¿æ¥å¤±è´¥: {str(e)}")
-+                return create_error_response(request_id, f"Failed to test server connection: {str(e)}")
-         
-         elif tool_name == "execute_remote_command":
-             try:
-@@ -548,24 +536,19 @@ async def handle_request(request):
-                 if not server_name:
-                     return create_error_response(request_id, "Server nameä¸èƒ½ä¸ºç©º")
-                 if not command:
--                    return create_error_response(request_id, "Command cannot be empty")
-+                    return create_error_response(request_id, "Commandä¸èƒ½ä¸ºç©º")
-                 
-                 manager = get_ssh_manager()
-                 if not manager:
--                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-+                    return create_error_response(request_id, "SSH manager initialization failed")
-                 
-                 success, output = manager.execute_command(server_name, command)
-                 
--                result_text = f"ğŸ”§ åœ¨è¿œç¨‹Server **{server_name}** Execute command\n"
--                result_text += f"ğŸ“ Command: `{command}`\n\n"
--                
-                 if success:
--                    result_text += f"âœ… Execution successful\n\n{output}"
-+                    return create_success_response(request_id, f"âœ… Command on {server_name} executed successfully:\n\n{output}")
-                 else:
--                    result_text += f"âŒ Execution failed\n\n{output}"
--                
--                return create_success_response(request_id, result_text)
--                
-+                    return create_error_response(request_id, f"âŒ Command on {server_name} execution failed:\n\n{output}")
-+                    
-             except Exception as e:
-                 debug_log(f"Error in execute_remote_command: {e}")
-                 return create_error_response(request_id, f"Failed to execute remote command: {str(e)}")
-@@ -578,96 +561,46 @@ async def handle_request(request):
-                 
-                 manager = get_ssh_manager()
-                 if not manager:
--                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-+                    return create_error_response(request_id, "SSH manager initialization failed")
-                 
-                 status = manager.get_server_status(server_name)
-                 
--                if 'error' in status:
-+                if status.get('error'):
-                     return create_error_response(request_id, status['error'])
-                 
--                result_text = f"ğŸ–¥ï¸ ServerStatus: **{server_name}**\n\n"
--                result_text += f"ğŸ“ Address: {status['host']}\n"
--                result_text += f"ğŸ“ Description: {status['description']}\n"
--                
--                # æ˜¾ç¤ºServerè§„æ ¼
--                specs = status.get('specs', {})
--                if specs:
--                    result_text += f"\nğŸ”§ ç¡¬ä»¶é…ç½®:\n"
--                    if specs.get('cpu_cores'):
--                        result_text += f"   ğŸ–¥ï¸ CPU: {specs['cpu_cores']} æ ¸å¿ƒ\n"
--                    if specs.get('memory'):
--                        result_text += f"   ğŸ’¾ Memory: {specs['memory']}\n"
--                    if specs.get('gpu_count', 0) > 0:
--                        result_text += f"   ğŸ® GPU: {specs['gpu_count']}x {specs.get('gpu_type', 'Unknown')}\n"
--                
--                # æ˜¾ç¤ºè¿æ¥Status
--                status_icon = "ğŸŸ¢" if status['connected'] else "ğŸ”´"
--                result_text += f"\nğŸ“¶ è¿æ¥Status: {status_icon} {'Online' if status['connected'] else 'Offline'}\n"
--                
--                if status['last_check'] > 0:
--                    import datetime
--                    check_time = datetime.datetime.fromtimestamp(status['last_check'])
--                    result_text += f"â° Last check: {check_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
--                
--                # æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
--                info = status.get('info', {})
--                if info:
--                    result_text += f"\nğŸ“Š ç³»ç»Ÿä¿¡æ¯:\n"
--                    
--                    if 'hostname' in info:
--                        result_text += f"   ğŸ·ï¸ ä¸»æœºå: {info['hostname']}\n"
--                    
--                    if 'uptime' in info:
--                        result_text += f"   â±ï¸ è¿è¡Œæ—¶é—´: {info['uptime']}\n"
--                    
--                    if 'load' in info:
--                        result_text += f"   ğŸ“ˆ ç³»ç»Ÿè´Ÿè½½: {info['load']}\n"
--                    
--                    if 'memory' in info:
--                        result_text += f"   ğŸ’¾ Memoryä½¿ç”¨:\n{info['memory']}\n"
--                    
--                    if 'disk_usage' in info:
--                        result_text += f"   ğŸ’¿ ç£ç›˜ä½¿ç”¨:\n{info['disk_usage']}\n"
--                    
--                    if 'gpu_status' in info:
--                        result_text += f"   ğŸ® GPUStatus:\n{info['gpu_status']}\n"
-+                # æ ¼å¼åŒ–è¾“å‡º
-+                result_text = f"ğŸ–¥ï¸ Server Status: **{status['name']}**\n"
-+                result_text += f"   Host: {status['host']}\n"
-+                result_text += f"   Status: {'ğŸŸ¢ Connected' if status['connected'] else 'ğŸ”´ Disconnected'}\n"
-                 
--                return create_success_response(request_id, result_text)
-+                if status['info']:
-+                    result_text += f"\n**System Info:**\n"
-+                    for key, value in status['info'].items():
-+                        result_text += f"**{key.capitalize()}**:\n```\n{value}\n```\n"
-                 
-+                return create_success_response(request_id, result_text)
-+
-             except Exception as e:
-                 debug_log(f"Error in get_server_status: {e}")
--                return create_error_response(request_id, f"è·å–ServerStatuså¤±è´¥: {str(e)}")
-+                return create_error_response(request_id, f"Failed to get server status: {str(e)}")
-         
-         elif tool_name == "refresh_server_connections":
-             try:
-                 manager = get_ssh_manager()
-                 if not manager:
--                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-+                    return create_error_response(request_id, "SSH manager initialization failed")
-                 
-                 results = manager.refresh_all_connections()
-                 
--                if not results:
--                    return create_success_response(request_id, "ğŸ“­ æ²¡æœ‰é…ç½®ä»»ä½•Server")
--                
--                result_text = f"ğŸ”„ Refresh all server connection status\n\n"
--                
--                online_count = sum(1 for success in results.values() if success)
--                total_count = len(results)
--                
--                result_text += f"ğŸ“Š Total: {online_count}/{total_count} ServerOnline\n\n"
--                
--                for server_name, success in results.items():
--                    status_icon = "ğŸŸ¢" if success else "ğŸ”´"
--                    status_text = "Online" if success else "Offline"
--                    result_text += f"{status_icon} {server_name}: {status_text}\n"
--                
--                result_text += f"\nâ° åˆ·æ–°æ—¶é—´: {time.strftime('%Y-%m-%d %H:%M:%S')}"
-+                result_text = "ğŸ”„ Connection Status Refresh Results:\n\n"
-+                for server, success in results.items():
-+                    result_text += f"  {'âœ…' if success else 'âŒ'} {server}\n"
-                 
-                 return create_success_response(request_id, result_text)
-                 
-             except Exception as e:
-                 debug_log(f"Error in refresh_server_connections: {e}")
--                return create_error_response(request_id, f"åˆ·æ–°Serverè¿æ¥å¤±è´¥: {str(e)}")
-+                return create_error_response(request_id, f"Failed to refresh connections: {str(e)}")
-         
-         elif tool_name == "establish_connection":
-             try:
-@@ -860,64 +793,67 @@ async def handle_request(request):
-             return create_error_response(request_id, f"æœªçŸ¥å·¥å…·: {tool_name}", -32601)
-             
-     else:
--        response = {
--            "jsonrpc": "2.0",
--            "id": request_id,
--            "error": {
--                "code": -32601,
--                "message": "Method not supported"
--            }
--        }
--        debug_log(f"Error response: {json.dumps(response)}")
--        return response
-+        return create_error_response(request_id, "ä¸æ”¯æŒçš„è¯·æ±‚æ–¹æ³•", -32601)
-+
- 
- async def main():
--    """ä¸»å‡½æ•°"""
--    debug_log("=" * 50)
--    debug_log("REMOTE TERMINAL MCP SERVER STARTING")
--    debug_log("=" * 50)
--    debug_log(f"Python version: {sys.version}")
--    debug_log(f"Working directory: {os.getcwd()}")
--    debug_log(f"Environment: {dict(os.environ)}")
--    debug_log(f"Script path: {__file__}")
--    debug_log(f"Debug mode: {DEBUG}")
--    debug_log("=" * 50)
--    debug_log("Waiting for MCP requests...")
--    
-+    """ä¸»äº‹ä»¶å¾ªç¯"""
-+    debug_log("MCP server started, entering main event loop...")
-+    loop = asyncio.get_event_loop()
-+
-     while True:
-         try:
--            line = await asyncio.get_event_loop().run_in_executor(None, sys.stdin.readline)
-+            line = await loop.run_in_executor(None, sys.stdin.readline)
-+            
-             if not line:
--                debug_log("No more input, exiting...")
--                break
-+                debug_log("Stdin stream closed. Server will continue running and wait for new connections.")
-+                # å½“stdinå…³é—­æ—¶ï¼Œä¸è¦é€€å‡ºï¼Œè€Œæ˜¯æš‚åœä¸€ä¸‹å†ç»§ç»­å¾ªç¯
-+                # è¿™ä½¿å¾—æœåŠ¡åœ¨å®¢æˆ·ç«¯æ–­å¼€åä¾ç„¶ä¿æŒè¿è¡ŒçŠ¶æ€
-+                await asyncio.sleep(1) 
-+                continue
-+
-+            request = json.loads(line)
-             
--            if line.strip():
--                debug_log(f"RAW INPUT: {line.strip()}")
--                try:
--                    request = json.loads(line.strip())
--                    debug_log(f"PARSED REQUEST: {json.dumps(request, indent=2)}")
--                except json.JSONDecodeError as e:
--                    debug_log(f"JSON DECODE ERROR: {e}")
--                    debug_log(f"Raw line was: {repr(line)}")
--                    continue
--                    
--                response = await handle_request(request)
--                
--                # åªæœ‰å½“æœ‰å“åº”æ—¶æ‰è¾“å‡º
--                if response is not None:
--                    output = json.dumps(response)
--                    debug_log(f"SENDING RESPONSE: {output}")
--                    print(output, flush=True)
--                else:
--                    debug_log(f"NO RESPONSE GENERATED FOR REQUEST: {request.get('method')}")
--                
-+            # ä½¿ç”¨create_taskæ¥å¹¶å‘å¤„ç†è¯·æ±‚ï¼Œé¿å…é˜»å¡ä¸»å¾ªç¯
-+            asyncio.create_task(process_and_respond(request))
-+
-+        except json.JSONDecodeError:
-+            debug_log(f"Received invalid JSON, skipping: {line.strip()}")
-         except Exception as e:
--            debug_log(f"Error processing request: {e}")
--            continue
-+            debug_log(f"An unexpected error occurred in main loop: {e}")
-+            # è®°å½•å®Œæ•´çš„é”™è¯¯å †æ ˆä¿¡æ¯ï¼Œç”¨äºæ·±å…¥è¯Šæ–­
-+            debug_log(traceback.format_exc())
-+            # å‡ºç°æ„å¤–é”™è¯¯æ—¶ï¼ŒçŸ­æš‚ä¼‘çœ ï¼Œé¿å…CPUå ç”¨è¿‡é«˜
-+            await asyncio.sleep(1)
-+
-+
-+async def process_and_respond(request):
-+    """å¤„ç†å•ä¸ªè¯·æ±‚å¹¶å‘é€å“åº”"""
-+    try:
-+        response = await handle_request(request)
-+        if response:
-+            response_str = json.dumps(response)
-+            debug_log(f"Sending response: {response_str}")
-+            print(response_str, flush=True)
-+    except Exception as e:
-+        request_id = request.get("id")
-+        error_response = create_error_response(request_id, f"Error processing request: {e}")
-+        error_str = json.dumps(error_response)
-+        debug_log(f"Sending error response: {error_str}")
-+        print(error_str, flush=True)
-+
-+
-+def on_exit():
-+    """åœ¨è„šæœ¬ç»ˆæ­¢æ—¶æ‰§è¡Œçš„å‡½æ•°"""
-+    debug_log("Python script is now exiting. Goodbye!")
-+
-+# æ³¨å†Œ 'é—è¨€' å‡½æ•°
-+atexit.register(on_exit)
-+
- 
- if __name__ == "__main__":
-     try:
-         asyncio.run(main())
-     except KeyboardInterrupt:
--        debug_log("Received interrupt, exiting...")
--        pass
-\ No newline at end of file
-+        debug_log("Server manually interrupted. Exiting.")
-+        sys.exit(0)
-\ No newline at end of file
-diff --git a/python/ssh_manager.py b/python/ssh_manager.py
-old mode 100644
-new mode 100755
-index 8c1d398..4fee5ce
---- a/python/ssh_manager.py
-+++ b/python/ssh_manager.py
-@@ -176,10 +176,13 @@ class SSHManager:
-         try:
-             with open(self.config_path, 'r', encoding='utf-8') as f:
-                 config = yaml.safe_load(f)
-+        except Exception as e:
-+            raise Exception(f"è¯»å–æˆ–è§£æYAMLé…ç½®æ–‡ä»¶å¤±è´¥: {e}")
-             
--            # è§£æServeré…ç½®
-+        # è§£æServeré…ç½®ï¼Œå¹¶å¯¹æ¯ä¸ªæœåŠ¡å™¨è¿›è¡Œç‹¬ç«‹çš„å¼‚å¸¸å¤„ç†
-             servers_config = config.get('servers', {})
-             for server_name, server_config in servers_config.items():
-+            try:
-                 # ä¸ºscript_basedç±»å‹æ„å»ºspecså­—å…¸
-                 specs = server_config.get('specs', {})
-                 
-@@ -213,13 +216,15 @@ class SSHManager:
-                     connected=False,
-                     last_check=0
-                 )
-+            except Exception as server_e:
-+                log_output(f"âš ï¸ [è­¦å‘Š] è§£ææœåŠ¡å™¨ '{server_name}' çš„é…ç½®å¤±è´¥ï¼Œå·²è·³è¿‡ã€‚é”™è¯¯: {server_e}")
-             
-             # è§£æå…¨å±€è®¾ç½®
-+        try:
-             self.global_settings = config.get('global_settings', {})
-             self.security_settings = config.get('security', {})
--            
-         except Exception as e:
--            raise Exception(f"è§£æé…ç½®æ–‡ä»¶å¤±è´¥: {e}")
-+            log_output(f"âš ï¸ [è­¦å‘Š] è§£æå…¨å±€è®¾ç½®å¤±è´¥: {e}")
-     
-     def list_servers(self) -> List[Dict[str, Any]]:
-         """åˆ—å‡ºæ‰€æœ‰Server"""
-@@ -530,7 +535,7 @@ class SSHManager:
-             if connection_mode == 'double_jump_host':
-                 target_host = connection_config.get('second_jump', {}).get('host', server.host)
-             else:
--                target_host = connection_config.get('target', {}).get('host', server.host)
-+            target_host = connection_config.get('target', {}).get('host', server.host)
-             
-             if target_host:
-                 log_output(f"ğŸ¯ æ­¥éª¤2: è¿æ¥åˆ°ç›®æ ‡Server ({target_host})")
-diff --git a/scripts/post-install.js b/scripts/post-install.js
-index 6234ba8..3456f1c 100755
---- a/scripts/post-install.js
-+++ b/scripts/post-install.js
-@@ -163,8 +163,8 @@ class PostInstaller {
-         } catch (error) {
-             this.warnings.push(`Permission setting failed: ${error.message}`);
-             return false;
--        }
-     }
-+  }
- 
-     async createUserConfig() {
-         this.log('Creating user configuration directory...');
-@@ -184,8 +184,8 @@ class PostInstaller {
-         if (fs.existsSync(configTemplate) && !fs.existsSync(userConfig)) {
-             fs.copyFileSync(configTemplate, userConfig);
-             this.log(`Configuration template copied to: ${userConfig}`, 'success');
--        }
--        
-+}
-+
-         return configDir;
-     }
- 
-diff --git a/templates/connect_cpu_221.sh b/templates/connect_cpu_221.sh
-old mode 100644
-new mode 100755
diff --git a/index.js b/index.js
index 6438c59..fe13353 100644
--- a/index.js
+++ b/index.js
@@ -7,8 +7,8 @@
  * @version 0.1.0
  */
 
-const path = require('path');
 const fs = require('fs');
+const path = require('path');
 const { spawn } = require('child_process');
 
 class RemoteTerminalMCP {
@@ -28,23 +28,17 @@ class RemoteTerminalMCP {
     }
 
     async main() {
-        try {
-            if (this.args.isHelpMode) {
-                this.showHelp();
-                return;
-            }
-
-            if (this.args.isTestMode) {
-                await this.runTests();
-                return;
-            }
+        if (this.args.isHelpMode) {
+            this.showHelp();
+            return;
+        }
 
-            await this.startMCPServer();
-            
-        } catch (error) {
-            console.error('Error:', error.message);
-            process.exit(1);
+        if (this.args.isTestMode) {
+            await this.runTests();
+            // ä¸å† returnï¼Œç»§ç»­æ‰§è¡Œä»¥å¯åŠ¨æœåŠ¡
         }
+        
+        await this.startMCPServer();
     }
 
     showHelp() {
@@ -72,24 +66,15 @@ Examples:
         const pythonScript = path.join(this.pythonDir, 'mcp_server.py');
         
         if (!fs.existsSync(pythonScript)) {
-            if (this.args.isDebugMode) {
-                console.error(`Python script not found: ${pythonScript}`);
-            }
+            console.error('Python script not found, exiting.');
             process.exit(1);
         }
 
-        if (this.args.isDebugMode) {
-            console.error('Starting MCP Server...');
-            console.error(`Python script: ${pythonScript}`);
-        }
-
-        // è®¾ç½®ç¯å¢ƒå˜é‡
         const env = { ...process.env };
         if (this.args.isDebugMode || process.env.MCP_DEBUG) {
             env.MCP_DEBUG = '1';
         }
-
-        // å¯åŠ¨Python MCPæœåŠ¡å™¨
+        
         const mcp = spawn('python3', [pythonScript], {
             stdio: ['pipe', 'pipe', this.args.isDebugMode ? 'inherit' : 'pipe'],
             env: env
@@ -161,10 +146,9 @@ Examples:
             }, null, 2));
         } else {
             console.log(`âŒ ${tests.length - passedTests}/${tests.length} tests failed`);
-            process.exit(1);
+            // ä¸å†é€€å‡ºè¿›ç¨‹
         }
-
-        process.exit(0);
+        // ä¸å†é€€å‡ºè¿›ç¨‹
     }
 
     async testPythonScript() {
@@ -200,13 +184,13 @@ Examples:
     }
 }
 
-// ç›´æ¥æ‰§è¡Œ
+module.exports = RemoteTerminalMCP;
+
 if (require.main === module) {
     const terminal = new RemoteTerminalMCP();
     terminal.main().catch(error => {
-        console.error('Unhandled error:', error);
+        console.error(`Unhandled error in main execution: ${error.message}`);
+        console.error(error.stack);
         process.exit(1);
     });
-}
-
-module.exports = RemoteTerminalMCP;
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/package.json b/package.json
index ac1be9a..5b534d5 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@xuyehua/remote-terminal-mcp",
-  "version": "0.2.11",
+  "version": "0.2.21",
   "description": "Remote Terminal MCP Server - æ™ºèƒ½script-basedè¿æ¥ç³»ç»Ÿï¼Œå®Œæ•´é›†æˆconnect_cpu_221.shé€»è¾‘",
   "main": "index.js",
   "bin": {
@@ -44,6 +44,7 @@
     "config/",
     "templates/",
     "scripts/",
+    "ssh_manager.py",
     "requirements.txt",
     "README.md",
     "LICENSE"
diff --git a/python/mcp_server.py b/python/mcp_server.py
index 06aa391..e1e10a8 100644
--- a/python/mcp_server.py
+++ b/python/mcp_server.py
@@ -9,19 +9,19 @@ import asyncio
 import json
 import sys
 import os
-import subprocess
-import time
+import traceback
 from pathlib import Path
 
-# æ·»åŠ å½“å‰ç›®å½•åˆ°Pythonè·¯å¾„
-sys.path.append(str(Path(__file__).parent))
+# æ·»åŠ åŒ…æ ¹ç›®å½•åˆ°Pythonè·¯å¾„ï¼Œä»¥ä¾¿èƒ½æ‰¾åˆ°ssh_manager.pyç­‰æ¨¡å—
+package_root = Path(__file__).parent.parent
+sys.path.append(str(package_root))
 
 # è®¾ç½®å®‰é™æ¨¡å¼ï¼Œé˜²æ­¢SSH Manageræ˜¾ç¤ºå¯åŠ¨æ‘˜è¦
 os.environ['MCP_QUIET'] = '1'
 
 from ssh_manager import SSHManager
 
-# è°ƒè¯•æ¨¡å¼ - é»˜è®¤å¼€å¯ä»¥ä¾¿è¯Šæ–­é—®é¢˜
+# è°ƒè¯•æ¨¡å¼
 DEBUG = os.getenv('MCP_DEBUG', '1') == '1'
 
 # åˆå§‹åŒ–SSHç®¡ç†å™¨
@@ -33,7 +33,6 @@ def get_ssh_manager():
     if ssh_manager is None:
         try:
             ssh_manager = SSHManager()
-            debug_log("SSH manager initialized successfully")
         except Exception as e:
             debug_log(f"SSH manager initialization failed: {e}")
             ssh_manager = None
@@ -118,7 +117,7 @@ def list_tmux_sessions():
                 return "No active tmux sessions"
         else:
             return "Cannot access tmux (not installed or not running)"
-            
+        
     except FileNotFoundError:
         return "tmux not installed"
     except Exception as e:
@@ -159,44 +158,31 @@ async def handle_request(request):
     method = request.get("method", "")
     request_id = request.get("id")
     
-    debug_log(f"=== REQUEST START ===")
-    debug_log(f"Method: {method}")
-    debug_log(f"Request ID: {request_id}")
-    debug_log(f"Full request: {json.dumps(request, indent=2)}")
-    debug_log(f"=== PROCESSING ===")
+    debug_log(f"Received request: {method} (id: {request_id})")
     
-    debug_log(f"Received method: {method}, id: {request_id}")
-    
-    # å¦‚æœæ²¡æœ‰idï¼Œè¿™æ˜¯ä¸€ä¸ªé€šçŸ¥ï¼Œä¸éœ€è¦å“åº”
     if request_id is None:
-        debug_log(f"Received notification: {method}, no response needed")
-        if method.startswith("notifications/"):
-            debug_log(f"Handling notification: {method}")
         return None
-    
-    # å¤„ç†éœ€è¦å“åº”çš„è¯·æ±‚
-    if method == "initialize":
-        response = {
-            "jsonrpc": "2.0",
-            "id": request_id,
-            "result": {
-                "protocolVersion": "2024-11-05",
-                "capabilities": {},
-                "serverInfo": {
-                    "name": "remote-terminal-mcp",
-                    "version": "0.2.0"
+
+    try:
+        if method == "initialize":
+            return {
+                "jsonrpc": "2.0",
+                "id": request_id,
+                "result": {
+                    "protocolVersion": "2024-11-05",
+                    "capabilities": {},
+                    "serverInfo": {
+                        "name": "remote-terminal-mcp",
+                        "version": "0.2.1" # Version update
+                    }
                 }
             }
-        }
-        debug_log(f"Initialize response: {json.dumps(response)}")
-        return response
         
-    elif method == "tools/list":
-        response = {
-            "jsonrpc": "2.0",
-            "id": request_id,
-            "result": {
-                "tools": [
+        elif method == "tools/list":
+            return {
+                "jsonrpc": "2.0",
+                "id": request_id,
+                "result": { "tools": [
                     {
                         "name": "system_info",
                         "description": "Get system information and current status",
@@ -359,565 +345,83 @@ async def handle_request(request):
                             "required": ["server_name"]
                         }
                     }
-                ]
+                ]}
             }
-        }
-        debug_log(f"Tools list response: {json.dumps(response)}")
-        return response
-        
-    elif method == "tools/call":
-        # å¤„ç†å·¥å…·è°ƒç”¨
-        tool_name = request.get("params", {}).get("name", "")
-        arguments = request.get("params", {}).get("arguments", {})
-        
-        debug_log(f"Tool call: {tool_name}, arguments: {arguments}")
-        
-        if tool_name == "system_info":
-            try:
-                info = check_system_info()
-                return create_success_response(request_id, info)
-            except Exception as e:
-                debug_log(f"Error in system_info: {e}")
-                return create_error_response(request_id, f"Failed to get system info: {str(e)}")
-        
-        elif tool_name == "run_command":
-            try:
-                command = arguments.get("command", "")
-                working_directory = arguments.get("working_directory")
-                timeout = arguments.get("timeout", 30)
-                
-                if not command:
-                    return create_error_response(request_id, "Command cannot be empty")
-                
-                output, success = run_command(command, working_directory, timeout)
-                
-                result_text = f"Command: {command}\n"
-                if working_directory:
-                    result_text += f"Working directory: {working_directory}\n"
-                result_text += f"\n{output}"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in run_command: {e}")
-                return create_error_response(request_id, f"Command execution failed: {str(e)}")
-        
-        elif tool_name == "list_tmux_sessions":
-            try:
-                sessions = list_tmux_sessions()
-                return create_success_response(request_id, sessions)
-            except Exception as e:
-                debug_log(f"Error in list_tmux_sessions: {e}")
-                return create_error_response(request_id, f"Failed to list tmux sessions: {str(e)}")
-        
-        elif tool_name == "create_tmux_session":
-            try:
-                session_name = arguments.get("session_name", "")
-                working_directory = arguments.get("working_directory", "")
-                
-                if not session_name:
-                    return create_error_response(request_id, "Session name cannot be empty")
-                
-                # æ„å»ºtmuxCommand
-                cmd = f"tmux new-session -d -s '{session_name}'"
-                if working_directory:
-                    cmd += f" -c '{working_directory}'"
-                
-                output, success = run_command(cmd)
-                
-                if success:
-                    result_text = f"Successfully created tmux session: {session_name}\n"
-                    if working_directory:
-                        result_text += f"Working directory: {working_directory}\n"
-                    result_text += f"\nUse 'tmux attach -t {session_name}' to connect to session"
-                else:
-                    result_text = f"Failed to create tmux session:\n{output}"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in create_tmux_session: {e}")
-                return create_error_response(request_id, f"Failed to create tmux session: {str(e)}")
-        
-        elif tool_name == "list_directory":
-            try:
-                path = arguments.get("path", ".")
-                show_hidden = arguments.get("show_hidden", False)
-                
-                # æ„å»ºlsCommand
-                cmd = "ls -la" if show_hidden else "ls -l"
-                cmd += f" '{path}'"
-                
-                output, success = run_command(cmd)
-                
-                if success:
-                    result_text = f"ğŸ“ ç›®å½•å†…å®¹: {path}\n\n{output}"
-                else:
-                    result_text = f"âŒ æ— æ³•åˆ—å‡ºç›®å½•å†…å®¹:\n{output}"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in list_directory: {e}")
-                return create_error_response(request_id, f"Failed to list directory: {str(e)}")
-        
-        elif tool_name == "list_remote_servers":
-            try:
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                servers = manager.list_servers()
-                if not servers:
-                    return create_success_response(request_id, "ğŸ“­ No remote servers configured\n\nğŸ’¡ Please run ./scripts/init-config.sh to initialize configuration")
-                
-                result_text = f"ğŸ–¥ï¸ Configured remote servers ({len(servers)}ä¸ª):\n\n"
-                
-                for server in servers:
-                    status_icon = "ğŸŸ¢" if server['connected'] else "ğŸ”´"
-                    result_text += f"{status_icon} **{server['name']}** ({server['type']})\n"
-                    result_text += f"   ğŸ“ Address: {server['host']}\n"
-                    result_text += f"   ğŸ“ Description: {server['description']}\n"
-                    
-                    if server.get('jump_host'):
-                        result_text += f"   ğŸ”— Jump host: {server['jump_host']}\n"
-                    
-                    specs = server.get('specs', {})
-                    if specs:
-                        if specs.get('gpu_count', 0) > 0:
-                            result_text += f"   ğŸ® GPU: {specs['gpu_count']}x {specs.get('gpu_type', 'Unknown')}\n"
-                        result_text += f"   ğŸ’¾ Memory: {specs.get('memory', 'Unknown')}\n"
-                    
-                    if server['last_check'] > 0:
-                        import datetime
-                        check_time = datetime.datetime.fromtimestamp(server['last_check'])
-                        result_text += f"   â° Last check: {check_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
-                    
-                    result_text += "\n"
-                
-                default_server = manager.get_default_server()
-                if default_server:
-                    result_text += f"ğŸŒŸ Default server: {default_server}\n"
-                
-                result_text += "\nğŸ’¡ Use 'test_server_connection' to test connection status"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in list_remote_servers: {e}")
-                return create_error_response(request_id, f"Failed to list remote servers: {str(e)}")
-        
-        elif tool_name == "test_server_connection":
-            try:
-                server_name = arguments.get("server_name", "")
-                if not server_name:
-                    return create_error_response(request_id, "Server nameä¸èƒ½ä¸ºç©º")
-                
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                success, message = manager.test_connection(server_name)
-                
-                if success:
-                    result_text = f"âœ… Server connection test successful\n\n"
-                    result_text += f"ğŸ–¥ï¸ Server: {server_name}\n"
-                    result_text += f"ğŸ“¶ Status: {message}\n"
-                    result_text += f"ğŸ”— Connection normal, can execute remote commands"
-                else:
-                    result_text = f"âŒ Serverè¿æ¥æµ‹è¯•å¤±è´¥\n\n"
-                    result_text += f"ğŸ–¥ï¸ Server: {server_name}\n"
-                    result_text += f"âš ï¸ Error: {message}\n"
-                    result_text += f"\nğŸ’¡ Please check:\n"
-                    result_text += f"   â€¢ ServerAddresså’Œç«¯å£\n"
-                    result_text += f"   â€¢ SSH key configuration\n"
-                    result_text += f"   â€¢ Network connection\n"
-                    result_text += f"   â€¢ Serveræ˜¯å¦Online"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in test_server_connection: {e}")
-                return create_error_response(request_id, f"æµ‹è¯•Serverè¿æ¥å¤±è´¥: {str(e)}")
-        
-        elif tool_name == "execute_remote_command":
-            try:
-                server_name = arguments.get("server_name", "")
-                command = arguments.get("command", "")
-                
-                if not server_name:
-                    return create_error_response(request_id, "Server nameä¸èƒ½ä¸ºç©º")
-                if not command:
-                    return create_error_response(request_id, "Command cannot be empty")
-                
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                success, output = manager.execute_command(server_name, command)
-                
-                result_text = f"ğŸ”§ åœ¨è¿œç¨‹Server **{server_name}** Execute command\n"
-                result_text += f"ğŸ“ Command: `{command}`\n\n"
-                
-                if success:
-                    result_text += f"âœ… Execution successful\n\n{output}"
-                else:
-                    result_text += f"âŒ Execution failed\n\n{output}"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in execute_remote_command: {e}")
-                return create_error_response(request_id, f"Failed to execute remote command: {str(e)}")
-        
-        elif tool_name == "get_server_status":
-            try:
-                server_name = arguments.get("server_name", "")
-                if not server_name:
-                    return create_error_response(request_id, "Server nameä¸èƒ½ä¸ºç©º")
-                
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                status = manager.get_server_status(server_name)
-                
-                if 'error' in status:
-                    return create_error_response(request_id, status['error'])
-                
-                result_text = f"ğŸ–¥ï¸ ServerStatus: **{server_name}**\n\n"
-                result_text += f"ğŸ“ Address: {status['host']}\n"
-                result_text += f"ğŸ“ Description: {status['description']}\n"
-                
-                # æ˜¾ç¤ºServerè§„æ ¼
-                specs = status.get('specs', {})
-                if specs:
-                    result_text += f"\nğŸ”§ ç¡¬ä»¶é…ç½®:\n"
-                    if specs.get('cpu_cores'):
-                        result_text += f"   ğŸ–¥ï¸ CPU: {specs['cpu_cores']} æ ¸å¿ƒ\n"
-                    if specs.get('memory'):
-                        result_text += f"   ğŸ’¾ Memory: {specs['memory']}\n"
-                    if specs.get('gpu_count', 0) > 0:
-                        result_text += f"   ğŸ® GPU: {specs['gpu_count']}x {specs.get('gpu_type', 'Unknown')}\n"
-                
-                # æ˜¾ç¤ºè¿æ¥Status
-                status_icon = "ğŸŸ¢" if status['connected'] else "ğŸ”´"
-                result_text += f"\nğŸ“¶ è¿æ¥Status: {status_icon} {'Online' if status['connected'] else 'Offline'}\n"
-                
-                if status['last_check'] > 0:
-                    import datetime
-                    check_time = datetime.datetime.fromtimestamp(status['last_check'])
-                    result_text += f"â° Last check: {check_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
-                
-                # æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
-                info = status.get('info', {})
-                if info:
-                    result_text += f"\nğŸ“Š ç³»ç»Ÿä¿¡æ¯:\n"
-                    
-                    if 'hostname' in info:
-                        result_text += f"   ğŸ·ï¸ ä¸»æœºå: {info['hostname']}\n"
-                    
-                    if 'uptime' in info:
-                        result_text += f"   â±ï¸ è¿è¡Œæ—¶é—´: {info['uptime']}\n"
-                    
-                    if 'load' in info:
-                        result_text += f"   ğŸ“ˆ ç³»ç»Ÿè´Ÿè½½: {info['load']}\n"
-                    
-                    if 'memory' in info:
-                        result_text += f"   ğŸ’¾ Memoryä½¿ç”¨:\n{info['memory']}\n"
-                    
-                    if 'disk_usage' in info:
-                        result_text += f"   ğŸ’¿ ç£ç›˜ä½¿ç”¨:\n{info['disk_usage']}\n"
-                    
-                    if 'gpu_status' in info:
-                        result_text += f"   ğŸ® GPUStatus:\n{info['gpu_status']}\n"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in get_server_status: {e}")
-                return create_error_response(request_id, f"è·å–ServerStatuså¤±è´¥: {str(e)}")
-        
-        elif tool_name == "refresh_server_connections":
-            try:
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                results = manager.refresh_all_connections()
-                
-                if not results:
-                    return create_success_response(request_id, "ğŸ“­ æ²¡æœ‰é…ç½®ä»»ä½•Server")
-                
-                result_text = f"ğŸ”„ Refresh all server connection status\n\n"
-                
-                online_count = sum(1 for success in results.values() if success)
-                total_count = len(results)
-                
-                result_text += f"ğŸ“Š Total: {online_count}/{total_count} ServerOnline\n\n"
-                
-                for server_name, success in results.items():
-                    status_icon = "ğŸŸ¢" if success else "ğŸ”´"
-                    status_text = "Online" if success else "Offline"
-                    result_text += f"{status_icon} {server_name}: {status_text}\n"
-                
-                result_text += f"\nâ° åˆ·æ–°æ—¶é—´: {time.strftime('%Y-%m-%d %H:%M:%S')}"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in refresh_server_connections: {e}")
-                return create_error_response(request_id, f"åˆ·æ–°Serverè¿æ¥å¤±è´¥: {str(e)}")
-        
-        elif tool_name == "establish_connection":
-            try:
-                server_name = arguments.get("server_name", "")
-                force_recreate = arguments.get("force_recreate", False)
-                debug_mode = arguments.get("debug_mode", True)
-                
-                if not server_name:
-                    return create_error_response(request_id, "Server nameä¸èƒ½ä¸ºç©º")
-                
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                # è·å–Serveré…ç½®
-                server = manager.get_server(server_name)
-                if not server:
-                    available_servers = [s['name'] for s in manager.list_servers()]
-                    return create_error_response(request_id, 
-                        f"Server '{server_name}' does not exist\n\n"
-                        f"å¯ç”¨Server: {', '.join(available_servers) if available_servers else 'æ— '}\n\n"
-                        f"ğŸ’¡ Please checké…ç½®æ–‡ä»¶: ~/.remote-terminal-mcp/config.yaml")
-                
-                result_text = f"ğŸš€ å»ºç«‹è¿æ¥åˆ°Server: **{server_name}**\n\n"
-                
-                # æ­¥éª¤1: é…ç½®éªŒè¯
-                result_text += "ğŸ” **æ­¥éª¤1: é…ç½®éªŒè¯**\n"
-                config_issues = []
-                
-                # éªŒè¯å¿…è¦çš„é…ç½®å­—æ®µ
-                if server.type == "script_based":
-                    if not server.specs:
-                        config_issues.append("ç¼ºå°‘specsé…ç½®")
-                    else:
-                        connection_config = server.specs.get('connection', {})
-                        if not connection_config:
-                            config_issues.append("ç¼ºå°‘connectioné…ç½®")
-                        else:
-                            # éªŒè¯Jump hosté…ç½®
-                            if connection_config.get('mode') == 'jump_host':
-                                jump_host = connection_config.get('jump_host', {})
-                                if not jump_host.get('host'):
-                                    config_issues.append("Jump hosté…ç½®ç¼ºå°‘host")
-                                if not jump_host.get('password'):
-                                    config_issues.append("Jump hosté…ç½®ç¼ºå°‘password")
-                            
-                            # éªŒè¯ç›®æ ‡Serveré…ç½®
-                            target_config = connection_config.get('target', {})
-                            if not target_config.get('host'):
-                                config_issues.append("ç›®æ ‡Serveré…ç½®ç¼ºå°‘host")
-                
-                if config_issues:
-                    result_text += f"âŒ Configuration validation failed\n"
-                    for issue in config_issues:
-                        result_text += f"   â€¢ {issue}\n"
-                    result_text += f"\nğŸ”§ **ä¿®å¤å»ºè®®**:\n"
-                    result_text += f"ç¼–è¾‘é…ç½®æ–‡ä»¶: ~/.remote-terminal-mcp/config.yaml\n"
-                    result_text += f"åœ¨ servers.{server_name} ä¸‹æ·»åŠ ç¼ºå¤±çš„é…ç½®é¡¹\n"
-                    return create_error_response(request_id, result_text)
-                
-                result_text += "âœ… é…ç½®éªŒè¯é€šè¿‡\n\n"
-                
-                # æ­¥éª¤2: Sessionç®¡ç†
-                result_text += "ğŸ“‹ **æ­¥éª¤2: Sessionç®¡ç†**\n"
-                session_name = server.session.name if server.session else f"{server_name}_dev"
-                
-                # æ£€æŸ¥ç°æœ‰session
-                session_exists = False
-                try:
-                    check_result = subprocess.run(['tmux', 'has-session', '-t', session_name], 
-                                                capture_output=True)
-                    session_exists = (check_result.returncode == 0)
-                except:
-                    pass
-                
-                if session_exists:
-                    if force_recreate:
-                        result_text += f"ğŸ”„ å¼ºåˆ¶é‡å»ºsession: {session_name}\n"
-                        subprocess.run(['tmux', 'kill-session', '-t', session_name], capture_output=True)
-                        session_exists = False
-                    else:
-                        result_text += f"â™»ï¸ æ£€æµ‹åˆ°ç°æœ‰session: {session_name}\n"
-                        # æ£€æŸ¥sessionStatus
-                        try:
-                            pane_content = subprocess.run(['tmux', 'capture-pane', '-t', session_name, '-p'], 
-                                                        capture_output=True, text=True)
-                            if pane_content.returncode == 0:
-                                # ç®€å•æ£€æŸ¥æ˜¯å¦çœ‹èµ·æ¥åƒæ˜¯æ´»è·ƒè¿æ¥
-                                content = pane_content.stdout.lower()
-                                if any(indicator in content for indicator in ['@', '$', '#', 'login', 'welcome']):
-                                    result_text += f"âœ… Session connection status good, use existing session directly\n"
-                                    result_text += f"\nğŸ¯ **Connection completed**\n"
-                                    result_text += f"ä½¿ç”¨Commandè¿æ¥: `tmux attach -t {session_name}`\n"
-                                    return create_success_response(request_id, result_text)
-                                else:
-                                    result_text += f"âš ï¸ Session exists but connection status unknown, will re-establish connection\n"
-                        except:
-                            result_text += f"âš ï¸ Cannot check session status, will re-establish connection\n"
-                
-                # Step 3: Establish connection
-                result_text += "\nğŸ”— **Step 3: Establish connection**\n"
-                
-                try:
-                    success, connection_message = manager._establish_script_based_connection(server)
-                    
-                    if success:
-                        result_text += f"âœ… Connection established successfully\n"
-                        result_text += f"ğŸ“ è¯¦æƒ…: {connection_message}\n"
-                        result_text += f"\nğŸ¯ **Connection completed**\n"
-                        result_text += f"ä½¿ç”¨Commandè¿æ¥: `tmux attach -t {session_name}`\n"
-                        
-                        # æä¾›å¿«é€ŸCommand
-                        result_text += f"\nğŸ’¡ **å¿«é€Ÿæ“ä½œ**:\n"
-                        result_text += f"â€¢ è¿æ¥session: `tmux attach -t {session_name}`\n"
-                        result_text += f"â€¢ åˆ†ç¦»session: Ctrl+B, ç„¶åæŒ‰ D\n"
-                        result_text += f"â€¢ æŸ¥çœ‹æ‰€æœ‰session: `tmux list-sessions`\n"
-                        
-                    else:
-                        # è¿æ¥å¤±è´¥å¤„ç†
-                        result_text += f"âŒ è¿æ¥å»ºç«‹å¤±è´¥\n"
-                        result_text += f"ğŸ“ Errorè¯¦æƒ…: {connection_message}\n"
-                        
-                        # æ™ºèƒ½Errorè¯Šæ–­
-                        result_text += f"\nğŸ”§ **Errorè¯Šæ–­å’Œä¿®å¤å»ºè®®**:\n"
-                        
-                        if "connection timed out" in connection_message.lower():
-                            result_text += f"â€¢ Network connectionè¶…æ—¶ - æ£€æŸ¥Network connectionå’ŒServerAddress\n"
-                            result_text += f"â€¢ å¦‚æœä½¿ç”¨Jump hostï¼ŒéªŒè¯Jump hostAddressæ˜¯å¦æ­£ç¡®\n"
-                        elif "permission denied" in connection_message.lower():
-                            result_text += f"â€¢ è®¤è¯å¤±è´¥ - æ£€æŸ¥ç”¨æˆ·åå’Œå¯†ç æ˜¯å¦æ­£ç¡®\n"
-                            result_text += f"â€¢ éªŒè¯SSH key configuration\n"
-                        elif "host unreachable" in connection_message.lower():
-                            result_text += f"â€¢ ä¸»æœºä¸å¯è¾¾ - æ£€æŸ¥Network connectionå’ŒIPAddress\n"
-                        else:
-                            result_text += f"â€¢ æ£€æŸ¥Serveré…ç½®æ–‡ä»¶\n"
-                            result_text += f"â€¢ éªŒè¯Network connectionå’Œè®¤è¯ä¿¡æ¯\n"
-                            result_text += f"â€¢ æ£€æŸ¥ç›®æ ‡Serveræ˜¯å¦è¿è¡Œ\n"
-                        
-                        # Sessionå¤„ç†ç­–ç•¥
-                        if debug_mode:
-                            # é‡å‘½åå¤±è´¥çš„sessionç”¨äºè°ƒè¯•
-                            debug_session_name = f"{session_name}_debug_{int(time.time())}"
-                            try:
-                                subprocess.run(['tmux', 'rename-session', '-t', session_name, debug_session_name], 
-                                             capture_output=True)
-                                result_text += f"\nğŸ› **è°ƒè¯•æ¨¡å¼**:\n"
-                                result_text += f"å¤±è´¥çš„sessionå·²é‡å‘½åä¸º: `{debug_session_name}`\n"
-                                result_text += f"ä½¿ç”¨ `tmux attach -t {debug_session_name}` æŸ¥çœ‹ç°åœº\n"
-                                result_text += f"è°ƒè¯•å®Œæˆåä½¿ç”¨ `tmux kill-session -t {debug_session_name}` æ¸…ç†\n"
-                            except:
-                                result_text += f"\nâš ï¸ æ— æ³•é‡å‘½ådebug session\n"
-                        else:
-                            # ç›´æ¥åˆ é™¤å¤±è´¥çš„session
-                            try:
-                                subprocess.run(['tmux', 'kill-session', '-t', session_name], capture_output=True)
-                                result_text += f"\nğŸ§¹ å¤±è´¥çš„sessionå·²æ¸…ç†\n"
-                            except:
-                                pass
-                        
-                        return create_error_response(request_id, result_text)
-                
-                except Exception as e:
-                    error_message = str(e)
-                    result_text += f"âŒ è¿æ¥è¿‡ç¨‹å¼‚å¸¸\n"
-                    result_text += f"ğŸ“ å¼‚å¸¸è¯¦æƒ…: {error_message}\n"
-                    
-                    result_text += f"\nğŸ”§ **å¼‚å¸¸å¤„ç†å»ºè®®**:\n"
-                    result_text += f"â€¢ æ£€æŸ¥SSHç®¡ç†å™¨é…ç½®\n"
-                    result_text += f"â€¢ éªŒè¯Serveré…ç½®å®Œæ•´æ€§\n"
-                    result_text += f"â€¢ é‡å¯MCPServer\n"
-                    
-                    if debug_mode and session_exists:
-                        debug_session_name = f"{session_name}_error_{int(time.time())}"
-                        try:
-                            subprocess.run(['tmux', 'rename-session', '-t', session_name, debug_session_name], 
-                                         capture_output=True)
-                            result_text += f"\nğŸ› å¼‚å¸¸sessionå·²ä¿ç•™ä¸º: `{debug_session_name}`\n"
-                        except:
-                            pass
-                    
-                    return create_error_response(request_id, result_text)
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in establish_connection: {e}")
-                return create_error_response(request_id, f"å»ºç«‹è¿æ¥å¤±è´¥: {str(e)}")
-        
-        else:
-            return create_error_response(request_id, f"æœªçŸ¥å·¥å…·: {tool_name}", -32601)
             
-    else:
-        response = {
-            "jsonrpc": "2.0",
-            "id": request_id,
-            "error": {
-                "code": -32601,
-                "message": "Method not supported"
-            }
-        }
-        debug_log(f"Error response: {json.dumps(response)}")
-        return response
+        elif method == "tools/run":
+            tool_name = request.get("params", {}).get("name")
+            tool_input = request.get("params", {}).get("input", {})
+            
+            if tool_name == "connect_to_server":
+                server_name = tool_input.get("server_name")
+                # ... (logic for connect_to_server)
+            # ... (other tools)
+            else:
+                return create_error_response(request_id, f"Unknown tool: {tool_name}")
+        else:
+            return create_error_response(request_id, f"Unknown method: {method}", -32601)
+
+    except Exception as e:
+        tb_str = traceback.format_exc()
+        error_msg = f"An unexpected error occurred: {e}\n{tb_str}"
+        debug_log(error_msg)
+        return create_error_response(request_id, error_msg)
 
 async def main():
     """ä¸»å‡½æ•°"""
-    debug_log("=" * 50)
-    debug_log("REMOTE TERMINAL MCP SERVER STARTING")
-    debug_log("=" * 50)
-    debug_log(f"Python version: {sys.version}")
-    debug_log(f"Working directory: {os.getcwd()}")
-    debug_log(f"Environment: {dict(os.environ)}")
-    debug_log(f"Script path: {__file__}")
-    debug_log(f"Debug mode: {DEBUG}")
-    debug_log("=" * 50)
-    debug_log("Waiting for MCP requests...")
+    debug_log("MCP server started, waiting for requests...")
+    # ä½¿ç”¨æ›´å¥å£®çš„è¡Œè¯»å–æ–¹å¼ï¼Œè€Œä¸æ˜¯ä¾èµ–ç®¡é“çŠ¶æ€
+    reader = asyncio.StreamReader()
+    protocol = asyncio.StreamReaderProtocol(reader)
+    loop = asyncio.get_event_loop()
     
-    while True:
+    # å°†æ ‡å‡†è¾“å…¥è®¾ç½®ä¸ºéé˜»å¡
+    if sys.platform != "win32":
+        import os
+        fd = sys.stdin.fileno()
+        os.set_blocking(fd, False)
+
+    await loop.connect_read_pipe(lambda: protocol, sys.stdin)
+
+    while True: # ä¸»å¾ªç¯åº”è¯¥æ°¸è¿œè¿è¡Œï¼Œç›´åˆ°è¢«å¤–éƒ¨ç»ˆæ­¢
         try:
-            line = await asyncio.get_event_loop().run_in_executor(None, sys.stdin.readline)
-            if not line:
-                debug_log("No more input, exiting...")
-                break
+            # æŒç»­ç­‰å¾…å¹¶å¤„ç†è¯·æ±‚
+            header = await reader.readuntil(b'\\r\\n\\r\\n')
+            content_length_header = header.decode('utf-8').split('\\r\\n')[0]
             
-            if line.strip():
-                debug_log(f"RAW INPUT: {line.strip()}")
-                try:
-                    request = json.loads(line.strip())
-                    debug_log(f"PARSED REQUEST: {json.dumps(request, indent=2)}")
-                except json.JSONDecodeError as e:
-                    debug_log(f"JSON DECODE ERROR: {e}")
-                    debug_log(f"Raw line was: {repr(line)}")
-                    continue
-                    
-                response = await handle_request(request)
+            if content_length_header.startswith("Content-Length: "):
+                content_length = int(content_length_header.split(': ')[1])
+                body = await reader.readexactly(content_length)
                 
-                # åªæœ‰å½“æœ‰å“åº”æ—¶æ‰è¾“å‡º
-                if response is not None:
-                    output = json.dumps(response)
-                    debug_log(f"SENDING RESPONSE: {output}")
-                    print(output, flush=True)
-                else:
-                    debug_log(f"NO RESPONSE GENERATED FOR REQUEST: {request.get('method')}")
-                
-        except Exception as e:
-            debug_log(f"Error processing request: {e}")
+                request = json.loads(body.decode('utf-8'))
+                response = await handle_request(request)
+                if response:
+                    response_body = json.dumps(response).encode('utf-8')
+                    # ç¡®ä¿å†™å› stdout
+                    sys.stdout.buffer.write(f"Content-Length: {len(response_body)}\\r\\n\\r\\n".encode('utf-8'))
+                    sys.stdout.buffer.write(response_body)
+                    sys.stdout.flush()
+        
+        except asyncio.IncompleteReadError:
+            # å½“stdinå…³é—­æ—¶ï¼Œè¿™ä¼šæ˜¯æœ€å¸¸è§çš„"é”™è¯¯"ï¼Œæˆ‘ä»¬åº”è¯¥ä¼˜é›…åœ°é€€å‡º
+            debug_log("Input stream closed, shutting down.")
+            break
+        except json.JSONDecodeError as e:
+            debug_log(f"JSON decode error: {e}")
+            # å³ä½¿è§£ç å¤±è´¥ï¼Œä¹Ÿåº”è¯¥ç»§ç»­ç­‰å¾…ä¸‹ä¸€ä¸ªè¯·æ±‚
             continue
+        except Exception as e:
+            tb_str = traceback.format_exc()
+            debug_log(f"Error in main loop: {e}\\n{tb_str}")
+            # å‘ç”Ÿå…¶ä»–é”™è¯¯æ—¶ï¼ŒçŸ­æš‚ç­‰å¾…åç»§ç»­ï¼Œå¢åŠ ç¨³å®šæ€§
+            await asyncio.sleep(1)
 
 if __name__ == "__main__":
     try:
         asyncio.run(main())
     except KeyboardInterrupt:
-        debug_log("Received interrupt, exiting...")
-        pass
\ No newline at end of file
+        debug_log("Server stopped by user.")
+    except Exception as e:
+        tb_str = traceback.format_exc()
+        debug_log(f"FATAL error: {e}\n{tb_str}")
+        sys.exit(1)
\ No newline at end of file
