diff --git a/bin/cli.js b/bin/cli.js
index 1ac5796..9197c2a 100755
--- a/bin/cli.js
+++ b/bin/cli.js
@@ -273,6 +273,13 @@ Documentation: https://github.com/maricoxu/remote-terminal-mcp
     }
 
     run() {
+        // 如果是通过MCP（非TTY环境）调用，则直接启动服务
+        const isMCPCall = !process.stdin.isTTY;
+        if (isMCPCall) {
+            this.start();
+            return;
+        }
+
         const args = process.argv.slice(2);
         const command = args[0];
 
@@ -296,7 +303,8 @@ Documentation: https://github.com/maricoxu/remote-terminal-mcp
                 break;
             default:
                 if (!command) {
-                    this.start(); // Default start MCP server
+                    // 对于交互式CLI，没有命令时显示帮助
+                    this.showHelp();
                 } else {
                     this.log(`Unknown command: ${command}`, 'error');
                     this.showHelp();
diff --git a/debugging_fixes.patch b/debugging_fixes.patch
index 5efd449..e69de29 100644
--- a/debugging_fixes.patch
+++ b/debugging_fixes.patch
@@ -1,484 +0,0 @@
-diff --git a/index.js b/index.js
-old mode 100644
-new mode 100755
-index 6438c59..6936d9b
---- a/index.js
-+++ b/index.js
-@@ -88,6 +88,7 @@ Examples:
-         if (this.args.isDebugMode || process.env.MCP_DEBUG) {
-             env.MCP_DEBUG = '1';
-         }
-+        env.REMOTE_TERMINAL_MCP_ROOT = this.packageDir;
- 
-         // 启动Python MCP服务器
-         const mcp = spawn('python3', [pythonScript], {
-@@ -99,17 +100,26 @@ Examples:
-         process.stdin.pipe(mcp.stdin);
-         mcp.stdout.pipe(process.stdout);
- 
--        // 处理进程事件
--        mcp.on('close', (code) => {
-+        // 增强日志：监控父进程stdin关闭事件
-+        process.stdin.on('close', () => {
-             if (this.args.isDebugMode) {
--                console.error(`MCP server exited with code: ${code}`);
-+                console.error('[DIAGNOSTIC] Parent process stdin stream has been closed.');
-             }
--            process.exit(code);
-         });
- 
-+        // 增强日志：处理子进程退出事件
-+        mcp.on('close', (code, signal) => {
-+            if (this.args.isDebugMode) {
-+                console.error(`[DIAGNOSTIC] Child process exited. Code: ${code}, Signal: ${signal}`);
-+            }
-+            // 保持原有逻辑，父进程随子进程退出
-+            process.exit(code === null ? 1 : code);
-+        });
-+
-+        // 增强日志：处理子进程错误事件
-         mcp.on('error', (error) => {
-             if (this.args.isDebugMode) {
--                console.error('MCP server error:', error.message);
-+                console.error('[DIAGNOSTIC] Child process error event:', error.message);
-             }
-             process.exit(1);
-         });
-diff --git a/lib/config-manager.js b/lib/config-manager.js
-index 996913b..0045146 100644
---- a/lib/config-manager.js
-+++ b/lib/config-manager.js
-@@ -10,7 +10,7 @@ const chalk = require('chalk');
-  */
- class ConfigManager {
-     constructor() {
--        this.configDir = path.join(os.homedir(), '.cursor-bridge');
-+        this.configDir = path.join(os.homedir(), '.remote-terminal-mcp');
-         this.configFile = path.join(this.configDir, 'config.yaml');
-         this.serversConfigFile = path.join(this.configDir, 'servers.yaml');
-     }
-diff --git a/package.json b/package.json
-index ac1be9a..d066706 100644
---- a/package.json
-+++ b/package.json
-@@ -4,7 +4,7 @@
-   "description": "Remote Terminal MCP Server - 智能script-based连接系统，完整集成connect_cpu_221.sh逻辑",
-   "main": "index.js",
-   "bin": {
--    "remote-terminal-mcp": "bin/cli.js"
-+    "remote-terminal-mcp": "index.js"
-   },
-   "scripts": {
-     "start": "node index.js",
-@@ -14,9 +14,9 @@
-     "prepublishOnly": "npm test"
-   },
-   "keywords": [
--    "mcp",
--    "remote",
--    "terminal",
-+    "mcp", 
-+    "remote", 
-+    "terminal", 
-     "cursor",
-     "claude",
-     "script-based",
-diff --git a/python/mcp_server.py b/python/mcp_server.py
-index 06aa391..6147df2 100644
---- a/python/mcp_server.py
-+++ b/python/mcp_server.py
-@@ -12,6 +12,8 @@ import os
- import subprocess
- import time
- from pathlib import Path
-+import atexit
-+import traceback
- 
- # 添加当前目录到Python路径
- sys.path.append(str(Path(__file__).parent))
-@@ -499,8 +501,6 @@ async def handle_request(request):
-                 if default_server:
-                     result_text += f"🌟 Default server: {default_server}\n"
-                 
--                result_text += "\n💡 Use 'test_server_connection' to test connection status"
--                
-                 return create_success_response(request_id, result_text)
-                 
-             except Exception as e:
-@@ -515,30 +515,18 @@ async def handle_request(request):
-                 
-                 manager = get_ssh_manager()
-                 if not manager:
--                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-+                    return create_error_response(request_id, "SSH manager initialization failed")
-                 
--                success, message = manager.test_connection(server_name)
-+                success, msg = manager.test_connection(server_name)
-                 
-                 if success:
--                    result_text = f"✅ Server connection test successful\n\n"
--                    result_text += f"🖥️ Server: {server_name}\n"
--                    result_text += f"📶 Status: {message}\n"
--                    result_text += f"🔗 Connection normal, can execute remote commands"
-+                    return create_success_response(request_id, f"✅ Server {server_name} connection successful: {msg}")
-                 else:
--                    result_text = f"❌ Server连接测试失败\n\n"
--                    result_text += f"🖥️ Server: {server_name}\n"
--                    result_text += f"⚠️ Error: {message}\n"
--                    result_text += f"\n💡 Please check:\n"
--                    result_text += f"   • ServerAddress和端口\n"
--                    result_text += f"   • SSH key configuration\n"
--                    result_text += f"   • Network connection\n"
--                    result_text += f"   • Server是否Online"
--                
--                return create_success_response(request_id, result_text)
--                
-+                    return create_error_response(request_id, f"❌ Server {server_name} connection failed: {msg}")
-+                    
-             except Exception as e:
-                 debug_log(f"Error in test_server_connection: {e}")
--                return create_error_response(request_id, f"测试Server连接失败: {str(e)}")
-+                return create_error_response(request_id, f"Failed to test server connection: {str(e)}")
-         
-         elif tool_name == "execute_remote_command":
-             try:
-@@ -548,24 +536,19 @@ async def handle_request(request):
-                 if not server_name:
-                     return create_error_response(request_id, "Server name不能为空")
-                 if not command:
--                    return create_error_response(request_id, "Command cannot be empty")
-+                    return create_error_response(request_id, "Command不能为空")
-                 
-                 manager = get_ssh_manager()
-                 if not manager:
--                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-+                    return create_error_response(request_id, "SSH manager initialization failed")
-                 
-                 success, output = manager.execute_command(server_name, command)
-                 
--                result_text = f"🔧 在远程Server **{server_name}** Execute command\n"
--                result_text += f"📝 Command: `{command}`\n\n"
--                
-                 if success:
--                    result_text += f"✅ Execution successful\n\n{output}"
-+                    return create_success_response(request_id, f"✅ Command on {server_name} executed successfully:\n\n{output}")
-                 else:
--                    result_text += f"❌ Execution failed\n\n{output}"
--                
--                return create_success_response(request_id, result_text)
--                
-+                    return create_error_response(request_id, f"❌ Command on {server_name} execution failed:\n\n{output}")
-+                    
-             except Exception as e:
-                 debug_log(f"Error in execute_remote_command: {e}")
-                 return create_error_response(request_id, f"Failed to execute remote command: {str(e)}")
-@@ -578,96 +561,46 @@ async def handle_request(request):
-                 
-                 manager = get_ssh_manager()
-                 if not manager:
--                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-+                    return create_error_response(request_id, "SSH manager initialization failed")
-                 
-                 status = manager.get_server_status(server_name)
-                 
--                if 'error' in status:
-+                if status.get('error'):
-                     return create_error_response(request_id, status['error'])
-                 
--                result_text = f"🖥️ ServerStatus: **{server_name}**\n\n"
--                result_text += f"📍 Address: {status['host']}\n"
--                result_text += f"📝 Description: {status['description']}\n"
--                
--                # 显示Server规格
--                specs = status.get('specs', {})
--                if specs:
--                    result_text += f"\n🔧 硬件配置:\n"
--                    if specs.get('cpu_cores'):
--                        result_text += f"   🖥️ CPU: {specs['cpu_cores']} 核心\n"
--                    if specs.get('memory'):
--                        result_text += f"   💾 Memory: {specs['memory']}\n"
--                    if specs.get('gpu_count', 0) > 0:
--                        result_text += f"   🎮 GPU: {specs['gpu_count']}x {specs.get('gpu_type', 'Unknown')}\n"
--                
--                # 显示连接Status
--                status_icon = "🟢" if status['connected'] else "🔴"
--                result_text += f"\n📶 连接Status: {status_icon} {'Online' if status['connected'] else 'Offline'}\n"
--                
--                if status['last_check'] > 0:
--                    import datetime
--                    check_time = datetime.datetime.fromtimestamp(status['last_check'])
--                    result_text += f"⏰ Last check: {check_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
--                
--                # 显示详细信息
--                info = status.get('info', {})
--                if info:
--                    result_text += f"\n📊 系统信息:\n"
--                    
--                    if 'hostname' in info:
--                        result_text += f"   🏷️ 主机名: {info['hostname']}\n"
--                    
--                    if 'uptime' in info:
--                        result_text += f"   ⏱️ 运行时间: {info['uptime']}\n"
--                    
--                    if 'load' in info:
--                        result_text += f"   📈 系统负载: {info['load']}\n"
--                    
--                    if 'memory' in info:
--                        result_text += f"   💾 Memory使用:\n{info['memory']}\n"
--                    
--                    if 'disk_usage' in info:
--                        result_text += f"   💿 磁盘使用:\n{info['disk_usage']}\n"
--                    
--                    if 'gpu_status' in info:
--                        result_text += f"   🎮 GPUStatus:\n{info['gpu_status']}\n"
-+                # 格式化输出
-+                result_text = f"🖥️ Server Status: **{status['name']}**\n"
-+                result_text += f"   Host: {status['host']}\n"
-+                result_text += f"   Status: {'🟢 Connected' if status['connected'] else '🔴 Disconnected'}\n"
-                 
--                return create_success_response(request_id, result_text)
-+                if status['info']:
-+                    result_text += f"\n**System Info:**\n"
-+                    for key, value in status['info'].items():
-+                        result_text += f"**{key.capitalize()}**:\n```\n{value}\n```\n"
-                 
-+                return create_success_response(request_id, result_text)
-+
-             except Exception as e:
-                 debug_log(f"Error in get_server_status: {e}")
--                return create_error_response(request_id, f"获取ServerStatus失败: {str(e)}")
-+                return create_error_response(request_id, f"Failed to get server status: {str(e)}")
-         
-         elif tool_name == "refresh_server_connections":
-             try:
-                 manager = get_ssh_manager()
-                 if not manager:
--                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-+                    return create_error_response(request_id, "SSH manager initialization failed")
-                 
-                 results = manager.refresh_all_connections()
-                 
--                if not results:
--                    return create_success_response(request_id, "📭 没有配置任何Server")
--                
--                result_text = f"🔄 Refresh all server connection status\n\n"
--                
--                online_count = sum(1 for success in results.values() if success)
--                total_count = len(results)
--                
--                result_text += f"📊 Total: {online_count}/{total_count} ServerOnline\n\n"
--                
--                for server_name, success in results.items():
--                    status_icon = "🟢" if success else "🔴"
--                    status_text = "Online" if success else "Offline"
--                    result_text += f"{status_icon} {server_name}: {status_text}\n"
--                
--                result_text += f"\n⏰ 刷新时间: {time.strftime('%Y-%m-%d %H:%M:%S')}"
-+                result_text = "🔄 Connection Status Refresh Results:\n\n"
-+                for server, success in results.items():
-+                    result_text += f"  {'✅' if success else '❌'} {server}\n"
-                 
-                 return create_success_response(request_id, result_text)
-                 
-             except Exception as e:
-                 debug_log(f"Error in refresh_server_connections: {e}")
--                return create_error_response(request_id, f"刷新Server连接失败: {str(e)}")
-+                return create_error_response(request_id, f"Failed to refresh connections: {str(e)}")
-         
-         elif tool_name == "establish_connection":
-             try:
-@@ -860,64 +793,67 @@ async def handle_request(request):
-             return create_error_response(request_id, f"未知工具: {tool_name}", -32601)
-             
-     else:
--        response = {
--            "jsonrpc": "2.0",
--            "id": request_id,
--            "error": {
--                "code": -32601,
--                "message": "Method not supported"
--            }
--        }
--        debug_log(f"Error response: {json.dumps(response)}")
--        return response
-+        return create_error_response(request_id, "不支持的请求方法", -32601)
-+
- 
- async def main():
--    """主函数"""
--    debug_log("=" * 50)
--    debug_log("REMOTE TERMINAL MCP SERVER STARTING")
--    debug_log("=" * 50)
--    debug_log(f"Python version: {sys.version}")
--    debug_log(f"Working directory: {os.getcwd()}")
--    debug_log(f"Environment: {dict(os.environ)}")
--    debug_log(f"Script path: {__file__}")
--    debug_log(f"Debug mode: {DEBUG}")
--    debug_log("=" * 50)
--    debug_log("Waiting for MCP requests...")
--    
-+    """主事件循环"""
-+    debug_log("MCP server started, entering main event loop...")
-+    loop = asyncio.get_event_loop()
-+
-     while True:
-         try:
--            line = await asyncio.get_event_loop().run_in_executor(None, sys.stdin.readline)
-+            line = await loop.run_in_executor(None, sys.stdin.readline)
-+            
-             if not line:
--                debug_log("No more input, exiting...")
--                break
-+                debug_log("Stdin stream closed. Server will continue running and wait for new connections.")
-+                # 当stdin关闭时，不要退出，而是暂停一下再继续循环
-+                # 这使得服务在客户端断开后依然保持运行状态
-+                await asyncio.sleep(1) 
-+                continue
-+
-+            request = json.loads(line)
-             
--            if line.strip():
--                debug_log(f"RAW INPUT: {line.strip()}")
--                try:
--                    request = json.loads(line.strip())
--                    debug_log(f"PARSED REQUEST: {json.dumps(request, indent=2)}")
--                except json.JSONDecodeError as e:
--                    debug_log(f"JSON DECODE ERROR: {e}")
--                    debug_log(f"Raw line was: {repr(line)}")
--                    continue
--                    
--                response = await handle_request(request)
--                
--                # 只有当有响应时才输出
--                if response is not None:
--                    output = json.dumps(response)
--                    debug_log(f"SENDING RESPONSE: {output}")
--                    print(output, flush=True)
--                else:
--                    debug_log(f"NO RESPONSE GENERATED FOR REQUEST: {request.get('method')}")
--                
-+            # 使用create_task来并发处理请求，避免阻塞主循环
-+            asyncio.create_task(process_and_respond(request))
-+
-+        except json.JSONDecodeError:
-+            debug_log(f"Received invalid JSON, skipping: {line.strip()}")
-         except Exception as e:
--            debug_log(f"Error processing request: {e}")
--            continue
-+            debug_log(f"An unexpected error occurred in main loop: {e}")
-+            # 记录完整的错误堆栈信息，用于深入诊断
-+            debug_log(traceback.format_exc())
-+            # 出现意外错误时，短暂休眠，避免CPU占用过高
-+            await asyncio.sleep(1)
-+
-+
-+async def process_and_respond(request):
-+    """处理单个请求并发送响应"""
-+    try:
-+        response = await handle_request(request)
-+        if response:
-+            response_str = json.dumps(response)
-+            debug_log(f"Sending response: {response_str}")
-+            print(response_str, flush=True)
-+    except Exception as e:
-+        request_id = request.get("id")
-+        error_response = create_error_response(request_id, f"Error processing request: {e}")
-+        error_str = json.dumps(error_response)
-+        debug_log(f"Sending error response: {error_str}")
-+        print(error_str, flush=True)
-+
-+
-+def on_exit():
-+    """在脚本终止时执行的函数"""
-+    debug_log("Python script is now exiting. Goodbye!")
-+
-+# 注册 '遗言' 函数
-+atexit.register(on_exit)
-+
- 
- if __name__ == "__main__":
-     try:
-         asyncio.run(main())
-     except KeyboardInterrupt:
--        debug_log("Received interrupt, exiting...")
--        pass
-\ No newline at end of file
-+        debug_log("Server manually interrupted. Exiting.")
-+        sys.exit(0)
-\ No newline at end of file
-diff --git a/python/ssh_manager.py b/python/ssh_manager.py
-old mode 100644
-new mode 100755
-index 8c1d398..4fee5ce
---- a/python/ssh_manager.py
-+++ b/python/ssh_manager.py
-@@ -176,10 +176,13 @@ class SSHManager:
-         try:
-             with open(self.config_path, 'r', encoding='utf-8') as f:
-                 config = yaml.safe_load(f)
-+        except Exception as e:
-+            raise Exception(f"读取或解析YAML配置文件失败: {e}")
-             
--            # 解析Server配置
-+        # 解析Server配置，并对每个服务器进行独立的异常处理
-             servers_config = config.get('servers', {})
-             for server_name, server_config in servers_config.items():
-+            try:
-                 # 为script_based类型构建specs字典
-                 specs = server_config.get('specs', {})
-                 
-@@ -213,13 +216,15 @@ class SSHManager:
-                     connected=False,
-                     last_check=0
-                 )
-+            except Exception as server_e:
-+                log_output(f"⚠️ [警告] 解析服务器 '{server_name}' 的配置失败，已跳过。错误: {server_e}")
-             
-             # 解析全局设置
-+        try:
-             self.global_settings = config.get('global_settings', {})
-             self.security_settings = config.get('security', {})
--            
-         except Exception as e:
--            raise Exception(f"解析配置文件失败: {e}")
-+            log_output(f"⚠️ [警告] 解析全局设置失败: {e}")
-     
-     def list_servers(self) -> List[Dict[str, Any]]:
-         """列出所有Server"""
-@@ -530,7 +535,7 @@ class SSHManager:
-             if connection_mode == 'double_jump_host':
-                 target_host = connection_config.get('second_jump', {}).get('host', server.host)
-             else:
--                target_host = connection_config.get('target', {}).get('host', server.host)
-+            target_host = connection_config.get('target', {}).get('host', server.host)
-             
-             if target_host:
-                 log_output(f"🎯 步骤2: 连接到目标Server ({target_host})")
-diff --git a/scripts/post-install.js b/scripts/post-install.js
-index 6234ba8..3456f1c 100755
---- a/scripts/post-install.js
-+++ b/scripts/post-install.js
-@@ -163,8 +163,8 @@ class PostInstaller {
-         } catch (error) {
-             this.warnings.push(`Permission setting failed: ${error.message}`);
-             return false;
--        }
-     }
-+  }
- 
-     async createUserConfig() {
-         this.log('Creating user configuration directory...');
-@@ -184,8 +184,8 @@ class PostInstaller {
-         if (fs.existsSync(configTemplate) && !fs.existsSync(userConfig)) {
-             fs.copyFileSync(configTemplate, userConfig);
-             this.log(`Configuration template copied to: ${userConfig}`, 'success');
--        }
--        
-+}
-+
-         return configDir;
-     }
- 
-diff --git a/templates/connect_cpu_221.sh b/templates/connect_cpu_221.sh
-old mode 100644
-new mode 100755
diff --git a/index.js b/index.js
index 6438c59..fe13353 100644
--- a/index.js
+++ b/index.js
@@ -7,8 +7,8 @@
  * @version 0.1.0
  */
 
-const path = require('path');
 const fs = require('fs');
+const path = require('path');
 const { spawn } = require('child_process');
 
 class RemoteTerminalMCP {
@@ -28,23 +28,17 @@ class RemoteTerminalMCP {
     }
 
     async main() {
-        try {
-            if (this.args.isHelpMode) {
-                this.showHelp();
-                return;
-            }
-
-            if (this.args.isTestMode) {
-                await this.runTests();
-                return;
-            }
+        if (this.args.isHelpMode) {
+            this.showHelp();
+            return;
+        }
 
-            await this.startMCPServer();
-            
-        } catch (error) {
-            console.error('Error:', error.message);
-            process.exit(1);
+        if (this.args.isTestMode) {
+            await this.runTests();
+            // 不再 return，继续执行以启动服务
         }
+        
+        await this.startMCPServer();
     }
 
     showHelp() {
@@ -72,24 +66,15 @@ Examples:
         const pythonScript = path.join(this.pythonDir, 'mcp_server.py');
         
         if (!fs.existsSync(pythonScript)) {
-            if (this.args.isDebugMode) {
-                console.error(`Python script not found: ${pythonScript}`);
-            }
+            console.error('Python script not found, exiting.');
             process.exit(1);
         }
 
-        if (this.args.isDebugMode) {
-            console.error('Starting MCP Server...');
-            console.error(`Python script: ${pythonScript}`);
-        }
-
-        // 设置环境变量
         const env = { ...process.env };
         if (this.args.isDebugMode || process.env.MCP_DEBUG) {
             env.MCP_DEBUG = '1';
         }
-
-        // 启动Python MCP服务器
+        
         const mcp = spawn('python3', [pythonScript], {
             stdio: ['pipe', 'pipe', this.args.isDebugMode ? 'inherit' : 'pipe'],
             env: env
@@ -161,10 +146,9 @@ Examples:
             }, null, 2));
         } else {
             console.log(`❌ ${tests.length - passedTests}/${tests.length} tests failed`);
-            process.exit(1);
+            // 不再退出进程
         }
-
-        process.exit(0);
+        // 不再退出进程
     }
 
     async testPythonScript() {
@@ -200,13 +184,13 @@ Examples:
     }
 }
 
-// 直接执行
+module.exports = RemoteTerminalMCP;
+
 if (require.main === module) {
     const terminal = new RemoteTerminalMCP();
     terminal.main().catch(error => {
-        console.error('Unhandled error:', error);
+        console.error(`Unhandled error in main execution: ${error.message}`);
+        console.error(error.stack);
         process.exit(1);
     });
-}
-
-module.exports = RemoteTerminalMCP;
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/package.json b/package.json
index ac1be9a..5b534d5 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@xuyehua/remote-terminal-mcp",
-  "version": "0.2.11",
+  "version": "0.2.21",
   "description": "Remote Terminal MCP Server - 智能script-based连接系统，完整集成connect_cpu_221.sh逻辑",
   "main": "index.js",
   "bin": {
@@ -44,6 +44,7 @@
     "config/",
     "templates/",
     "scripts/",
+    "ssh_manager.py",
     "requirements.txt",
     "README.md",
     "LICENSE"
diff --git a/python/mcp_server.py b/python/mcp_server.py
index 06aa391..e1e10a8 100644
--- a/python/mcp_server.py
+++ b/python/mcp_server.py
@@ -9,19 +9,19 @@ import asyncio
 import json
 import sys
 import os
-import subprocess
-import time
+import traceback
 from pathlib import Path
 
-# 添加当前目录到Python路径
-sys.path.append(str(Path(__file__).parent))
+# 添加包根目录到Python路径，以便能找到ssh_manager.py等模块
+package_root = Path(__file__).parent.parent
+sys.path.append(str(package_root))
 
 # 设置安静模式，防止SSH Manager显示启动摘要
 os.environ['MCP_QUIET'] = '1'
 
 from ssh_manager import SSHManager
 
-# 调试模式 - 默认开启以便诊断问题
+# 调试模式
 DEBUG = os.getenv('MCP_DEBUG', '1') == '1'
 
 # 初始化SSH管理器
@@ -33,7 +33,6 @@ def get_ssh_manager():
     if ssh_manager is None:
         try:
             ssh_manager = SSHManager()
-            debug_log("SSH manager initialized successfully")
         except Exception as e:
             debug_log(f"SSH manager initialization failed: {e}")
             ssh_manager = None
@@ -118,7 +117,7 @@ def list_tmux_sessions():
                 return "No active tmux sessions"
         else:
             return "Cannot access tmux (not installed or not running)"
-            
+        
     except FileNotFoundError:
         return "tmux not installed"
     except Exception as e:
@@ -159,44 +158,31 @@ async def handle_request(request):
     method = request.get("method", "")
     request_id = request.get("id")
     
-    debug_log(f"=== REQUEST START ===")
-    debug_log(f"Method: {method}")
-    debug_log(f"Request ID: {request_id}")
-    debug_log(f"Full request: {json.dumps(request, indent=2)}")
-    debug_log(f"=== PROCESSING ===")
+    debug_log(f"Received request: {method} (id: {request_id})")
     
-    debug_log(f"Received method: {method}, id: {request_id}")
-    
-    # 如果没有id，这是一个通知，不需要响应
     if request_id is None:
-        debug_log(f"Received notification: {method}, no response needed")
-        if method.startswith("notifications/"):
-            debug_log(f"Handling notification: {method}")
         return None
-    
-    # 处理需要响应的请求
-    if method == "initialize":
-        response = {
-            "jsonrpc": "2.0",
-            "id": request_id,
-            "result": {
-                "protocolVersion": "2024-11-05",
-                "capabilities": {},
-                "serverInfo": {
-                    "name": "remote-terminal-mcp",
-                    "version": "0.2.0"
+
+    try:
+        if method == "initialize":
+            return {
+                "jsonrpc": "2.0",
+                "id": request_id,
+                "result": {
+                    "protocolVersion": "2024-11-05",
+                    "capabilities": {},
+                    "serverInfo": {
+                        "name": "remote-terminal-mcp",
+                        "version": "0.2.1" # Version update
+                    }
                 }
             }
-        }
-        debug_log(f"Initialize response: {json.dumps(response)}")
-        return response
         
-    elif method == "tools/list":
-        response = {
-            "jsonrpc": "2.0",
-            "id": request_id,
-            "result": {
-                "tools": [
+        elif method == "tools/list":
+            return {
+                "jsonrpc": "2.0",
+                "id": request_id,
+                "result": { "tools": [
                     {
                         "name": "system_info",
                         "description": "Get system information and current status",
@@ -359,565 +345,83 @@ async def handle_request(request):
                             "required": ["server_name"]
                         }
                     }
-                ]
+                ]}
             }
-        }
-        debug_log(f"Tools list response: {json.dumps(response)}")
-        return response
-        
-    elif method == "tools/call":
-        # 处理工具调用
-        tool_name = request.get("params", {}).get("name", "")
-        arguments = request.get("params", {}).get("arguments", {})
-        
-        debug_log(f"Tool call: {tool_name}, arguments: {arguments}")
-        
-        if tool_name == "system_info":
-            try:
-                info = check_system_info()
-                return create_success_response(request_id, info)
-            except Exception as e:
-                debug_log(f"Error in system_info: {e}")
-                return create_error_response(request_id, f"Failed to get system info: {str(e)}")
-        
-        elif tool_name == "run_command":
-            try:
-                command = arguments.get("command", "")
-                working_directory = arguments.get("working_directory")
-                timeout = arguments.get("timeout", 30)
-                
-                if not command:
-                    return create_error_response(request_id, "Command cannot be empty")
-                
-                output, success = run_command(command, working_directory, timeout)
-                
-                result_text = f"Command: {command}\n"
-                if working_directory:
-                    result_text += f"Working directory: {working_directory}\n"
-                result_text += f"\n{output}"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in run_command: {e}")
-                return create_error_response(request_id, f"Command execution failed: {str(e)}")
-        
-        elif tool_name == "list_tmux_sessions":
-            try:
-                sessions = list_tmux_sessions()
-                return create_success_response(request_id, sessions)
-            except Exception as e:
-                debug_log(f"Error in list_tmux_sessions: {e}")
-                return create_error_response(request_id, f"Failed to list tmux sessions: {str(e)}")
-        
-        elif tool_name == "create_tmux_session":
-            try:
-                session_name = arguments.get("session_name", "")
-                working_directory = arguments.get("working_directory", "")
-                
-                if not session_name:
-                    return create_error_response(request_id, "Session name cannot be empty")
-                
-                # 构建tmuxCommand
-                cmd = f"tmux new-session -d -s '{session_name}'"
-                if working_directory:
-                    cmd += f" -c '{working_directory}'"
-                
-                output, success = run_command(cmd)
-                
-                if success:
-                    result_text = f"Successfully created tmux session: {session_name}\n"
-                    if working_directory:
-                        result_text += f"Working directory: {working_directory}\n"
-                    result_text += f"\nUse 'tmux attach -t {session_name}' to connect to session"
-                else:
-                    result_text = f"Failed to create tmux session:\n{output}"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in create_tmux_session: {e}")
-                return create_error_response(request_id, f"Failed to create tmux session: {str(e)}")
-        
-        elif tool_name == "list_directory":
-            try:
-                path = arguments.get("path", ".")
-                show_hidden = arguments.get("show_hidden", False)
-                
-                # 构建lsCommand
-                cmd = "ls -la" if show_hidden else "ls -l"
-                cmd += f" '{path}'"
-                
-                output, success = run_command(cmd)
-                
-                if success:
-                    result_text = f"📁 目录内容: {path}\n\n{output}"
-                else:
-                    result_text = f"❌ 无法列出目录内容:\n{output}"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in list_directory: {e}")
-                return create_error_response(request_id, f"Failed to list directory: {str(e)}")
-        
-        elif tool_name == "list_remote_servers":
-            try:
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                servers = manager.list_servers()
-                if not servers:
-                    return create_success_response(request_id, "📭 No remote servers configured\n\n💡 Please run ./scripts/init-config.sh to initialize configuration")
-                
-                result_text = f"🖥️ Configured remote servers ({len(servers)}个):\n\n"
-                
-                for server in servers:
-                    status_icon = "🟢" if server['connected'] else "🔴"
-                    result_text += f"{status_icon} **{server['name']}** ({server['type']})\n"
-                    result_text += f"   📍 Address: {server['host']}\n"
-                    result_text += f"   📝 Description: {server['description']}\n"
-                    
-                    if server.get('jump_host'):
-                        result_text += f"   🔗 Jump host: {server['jump_host']}\n"
-                    
-                    specs = server.get('specs', {})
-                    if specs:
-                        if specs.get('gpu_count', 0) > 0:
-                            result_text += f"   🎮 GPU: {specs['gpu_count']}x {specs.get('gpu_type', 'Unknown')}\n"
-                        result_text += f"   💾 Memory: {specs.get('memory', 'Unknown')}\n"
-                    
-                    if server['last_check'] > 0:
-                        import datetime
-                        check_time = datetime.datetime.fromtimestamp(server['last_check'])
-                        result_text += f"   ⏰ Last check: {check_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
-                    
-                    result_text += "\n"
-                
-                default_server = manager.get_default_server()
-                if default_server:
-                    result_text += f"🌟 Default server: {default_server}\n"
-                
-                result_text += "\n💡 Use 'test_server_connection' to test connection status"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in list_remote_servers: {e}")
-                return create_error_response(request_id, f"Failed to list remote servers: {str(e)}")
-        
-        elif tool_name == "test_server_connection":
-            try:
-                server_name = arguments.get("server_name", "")
-                if not server_name:
-                    return create_error_response(request_id, "Server name不能为空")
-                
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                success, message = manager.test_connection(server_name)
-                
-                if success:
-                    result_text = f"✅ Server connection test successful\n\n"
-                    result_text += f"🖥️ Server: {server_name}\n"
-                    result_text += f"📶 Status: {message}\n"
-                    result_text += f"🔗 Connection normal, can execute remote commands"
-                else:
-                    result_text = f"❌ Server连接测试失败\n\n"
-                    result_text += f"🖥️ Server: {server_name}\n"
-                    result_text += f"⚠️ Error: {message}\n"
-                    result_text += f"\n💡 Please check:\n"
-                    result_text += f"   • ServerAddress和端口\n"
-                    result_text += f"   • SSH key configuration\n"
-                    result_text += f"   • Network connection\n"
-                    result_text += f"   • Server是否Online"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in test_server_connection: {e}")
-                return create_error_response(request_id, f"测试Server连接失败: {str(e)}")
-        
-        elif tool_name == "execute_remote_command":
-            try:
-                server_name = arguments.get("server_name", "")
-                command = arguments.get("command", "")
-                
-                if not server_name:
-                    return create_error_response(request_id, "Server name不能为空")
-                if not command:
-                    return create_error_response(request_id, "Command cannot be empty")
-                
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                success, output = manager.execute_command(server_name, command)
-                
-                result_text = f"🔧 在远程Server **{server_name}** Execute command\n"
-                result_text += f"📝 Command: `{command}`\n\n"
-                
-                if success:
-                    result_text += f"✅ Execution successful\n\n{output}"
-                else:
-                    result_text += f"❌ Execution failed\n\n{output}"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in execute_remote_command: {e}")
-                return create_error_response(request_id, f"Failed to execute remote command: {str(e)}")
-        
-        elif tool_name == "get_server_status":
-            try:
-                server_name = arguments.get("server_name", "")
-                if not server_name:
-                    return create_error_response(request_id, "Server name不能为空")
-                
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                status = manager.get_server_status(server_name)
-                
-                if 'error' in status:
-                    return create_error_response(request_id, status['error'])
-                
-                result_text = f"🖥️ ServerStatus: **{server_name}**\n\n"
-                result_text += f"📍 Address: {status['host']}\n"
-                result_text += f"📝 Description: {status['description']}\n"
-                
-                # 显示Server规格
-                specs = status.get('specs', {})
-                if specs:
-                    result_text += f"\n🔧 硬件配置:\n"
-                    if specs.get('cpu_cores'):
-                        result_text += f"   🖥️ CPU: {specs['cpu_cores']} 核心\n"
-                    if specs.get('memory'):
-                        result_text += f"   💾 Memory: {specs['memory']}\n"
-                    if specs.get('gpu_count', 0) > 0:
-                        result_text += f"   🎮 GPU: {specs['gpu_count']}x {specs.get('gpu_type', 'Unknown')}\n"
-                
-                # 显示连接Status
-                status_icon = "🟢" if status['connected'] else "🔴"
-                result_text += f"\n📶 连接Status: {status_icon} {'Online' if status['connected'] else 'Offline'}\n"
-                
-                if status['last_check'] > 0:
-                    import datetime
-                    check_time = datetime.datetime.fromtimestamp(status['last_check'])
-                    result_text += f"⏰ Last check: {check_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
-                
-                # 显示详细信息
-                info = status.get('info', {})
-                if info:
-                    result_text += f"\n📊 系统信息:\n"
-                    
-                    if 'hostname' in info:
-                        result_text += f"   🏷️ 主机名: {info['hostname']}\n"
-                    
-                    if 'uptime' in info:
-                        result_text += f"   ⏱️ 运行时间: {info['uptime']}\n"
-                    
-                    if 'load' in info:
-                        result_text += f"   📈 系统负载: {info['load']}\n"
-                    
-                    if 'memory' in info:
-                        result_text += f"   💾 Memory使用:\n{info['memory']}\n"
-                    
-                    if 'disk_usage' in info:
-                        result_text += f"   💿 磁盘使用:\n{info['disk_usage']}\n"
-                    
-                    if 'gpu_status' in info:
-                        result_text += f"   🎮 GPUStatus:\n{info['gpu_status']}\n"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in get_server_status: {e}")
-                return create_error_response(request_id, f"获取ServerStatus失败: {str(e)}")
-        
-        elif tool_name == "refresh_server_connections":
-            try:
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                results = manager.refresh_all_connections()
-                
-                if not results:
-                    return create_success_response(request_id, "📭 没有配置任何Server")
-                
-                result_text = f"🔄 Refresh all server connection status\n\n"
-                
-                online_count = sum(1 for success in results.values() if success)
-                total_count = len(results)
-                
-                result_text += f"📊 Total: {online_count}/{total_count} ServerOnline\n\n"
-                
-                for server_name, success in results.items():
-                    status_icon = "🟢" if success else "🔴"
-                    status_text = "Online" if success else "Offline"
-                    result_text += f"{status_icon} {server_name}: {status_text}\n"
-                
-                result_text += f"\n⏰ 刷新时间: {time.strftime('%Y-%m-%d %H:%M:%S')}"
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in refresh_server_connections: {e}")
-                return create_error_response(request_id, f"刷新Server连接失败: {str(e)}")
-        
-        elif tool_name == "establish_connection":
-            try:
-                server_name = arguments.get("server_name", "")
-                force_recreate = arguments.get("force_recreate", False)
-                debug_mode = arguments.get("debug_mode", True)
-                
-                if not server_name:
-                    return create_error_response(request_id, "Server name不能为空")
-                
-                manager = get_ssh_manager()
-                if not manager:
-                    return create_error_response(request_id, "SSH manager initialization failed, please check configuration file")
-                
-                # 获取Server配置
-                server = manager.get_server(server_name)
-                if not server:
-                    available_servers = [s['name'] for s in manager.list_servers()]
-                    return create_error_response(request_id, 
-                        f"Server '{server_name}' does not exist\n\n"
-                        f"可用Server: {', '.join(available_servers) if available_servers else '无'}\n\n"
-                        f"💡 Please check配置文件: ~/.remote-terminal-mcp/config.yaml")
-                
-                result_text = f"🚀 建立连接到Server: **{server_name}**\n\n"
-                
-                # 步骤1: 配置验证
-                result_text += "🔍 **步骤1: 配置验证**\n"
-                config_issues = []
-                
-                # 验证必要的配置字段
-                if server.type == "script_based":
-                    if not server.specs:
-                        config_issues.append("缺少specs配置")
-                    else:
-                        connection_config = server.specs.get('connection', {})
-                        if not connection_config:
-                            config_issues.append("缺少connection配置")
-                        else:
-                            # 验证Jump host配置
-                            if connection_config.get('mode') == 'jump_host':
-                                jump_host = connection_config.get('jump_host', {})
-                                if not jump_host.get('host'):
-                                    config_issues.append("Jump host配置缺少host")
-                                if not jump_host.get('password'):
-                                    config_issues.append("Jump host配置缺少password")
-                            
-                            # 验证目标Server配置
-                            target_config = connection_config.get('target', {})
-                            if not target_config.get('host'):
-                                config_issues.append("目标Server配置缺少host")
-                
-                if config_issues:
-                    result_text += f"❌ Configuration validation failed\n"
-                    for issue in config_issues:
-                        result_text += f"   • {issue}\n"
-                    result_text += f"\n🔧 **修复建议**:\n"
-                    result_text += f"编辑配置文件: ~/.remote-terminal-mcp/config.yaml\n"
-                    result_text += f"在 servers.{server_name} 下添加缺失的配置项\n"
-                    return create_error_response(request_id, result_text)
-                
-                result_text += "✅ 配置验证通过\n\n"
-                
-                # 步骤2: Session管理
-                result_text += "📋 **步骤2: Session管理**\n"
-                session_name = server.session.name if server.session else f"{server_name}_dev"
-                
-                # 检查现有session
-                session_exists = False
-                try:
-                    check_result = subprocess.run(['tmux', 'has-session', '-t', session_name], 
-                                                capture_output=True)
-                    session_exists = (check_result.returncode == 0)
-                except:
-                    pass
-                
-                if session_exists:
-                    if force_recreate:
-                        result_text += f"🔄 强制重建session: {session_name}\n"
-                        subprocess.run(['tmux', 'kill-session', '-t', session_name], capture_output=True)
-                        session_exists = False
-                    else:
-                        result_text += f"♻️ 检测到现有session: {session_name}\n"
-                        # 检查sessionStatus
-                        try:
-                            pane_content = subprocess.run(['tmux', 'capture-pane', '-t', session_name, '-p'], 
-                                                        capture_output=True, text=True)
-                            if pane_content.returncode == 0:
-                                # 简单检查是否看起来像是活跃连接
-                                content = pane_content.stdout.lower()
-                                if any(indicator in content for indicator in ['@', '$', '#', 'login', 'welcome']):
-                                    result_text += f"✅ Session connection status good, use existing session directly\n"
-                                    result_text += f"\n🎯 **Connection completed**\n"
-                                    result_text += f"使用Command连接: `tmux attach -t {session_name}`\n"
-                                    return create_success_response(request_id, result_text)
-                                else:
-                                    result_text += f"⚠️ Session exists but connection status unknown, will re-establish connection\n"
-                        except:
-                            result_text += f"⚠️ Cannot check session status, will re-establish connection\n"
-                
-                # Step 3: Establish connection
-                result_text += "\n🔗 **Step 3: Establish connection**\n"
-                
-                try:
-                    success, connection_message = manager._establish_script_based_connection(server)
-                    
-                    if success:
-                        result_text += f"✅ Connection established successfully\n"
-                        result_text += f"📝 详情: {connection_message}\n"
-                        result_text += f"\n🎯 **Connection completed**\n"
-                        result_text += f"使用Command连接: `tmux attach -t {session_name}`\n"
-                        
-                        # 提供快速Command
-                        result_text += f"\n💡 **快速操作**:\n"
-                        result_text += f"• 连接session: `tmux attach -t {session_name}`\n"
-                        result_text += f"• 分离session: Ctrl+B, 然后按 D\n"
-                        result_text += f"• 查看所有session: `tmux list-sessions`\n"
-                        
-                    else:
-                        # 连接失败处理
-                        result_text += f"❌ 连接建立失败\n"
-                        result_text += f"📝 Error详情: {connection_message}\n"
-                        
-                        # 智能Error诊断
-                        result_text += f"\n🔧 **Error诊断和修复建议**:\n"
-                        
-                        if "connection timed out" in connection_message.lower():
-                            result_text += f"• Network connection超时 - 检查Network connection和ServerAddress\n"
-                            result_text += f"• 如果使用Jump host，验证Jump hostAddress是否正确\n"
-                        elif "permission denied" in connection_message.lower():
-                            result_text += f"• 认证失败 - 检查用户名和密码是否正确\n"
-                            result_text += f"• 验证SSH key configuration\n"
-                        elif "host unreachable" in connection_message.lower():
-                            result_text += f"• 主机不可达 - 检查Network connection和IPAddress\n"
-                        else:
-                            result_text += f"• 检查Server配置文件\n"
-                            result_text += f"• 验证Network connection和认证信息\n"
-                            result_text += f"• 检查目标Server是否运行\n"
-                        
-                        # Session处理策略
-                        if debug_mode:
-                            # 重命名失败的session用于调试
-                            debug_session_name = f"{session_name}_debug_{int(time.time())}"
-                            try:
-                                subprocess.run(['tmux', 'rename-session', '-t', session_name, debug_session_name], 
-                                             capture_output=True)
-                                result_text += f"\n🐛 **调试模式**:\n"
-                                result_text += f"失败的session已重命名为: `{debug_session_name}`\n"
-                                result_text += f"使用 `tmux attach -t {debug_session_name}` 查看现场\n"
-                                result_text += f"调试完成后使用 `tmux kill-session -t {debug_session_name}` 清理\n"
-                            except:
-                                result_text += f"\n⚠️ 无法重命名debug session\n"
-                        else:
-                            # 直接删除失败的session
-                            try:
-                                subprocess.run(['tmux', 'kill-session', '-t', session_name], capture_output=True)
-                                result_text += f"\n🧹 失败的session已清理\n"
-                            except:
-                                pass
-                        
-                        return create_error_response(request_id, result_text)
-                
-                except Exception as e:
-                    error_message = str(e)
-                    result_text += f"❌ 连接过程异常\n"
-                    result_text += f"📝 异常详情: {error_message}\n"
-                    
-                    result_text += f"\n🔧 **异常处理建议**:\n"
-                    result_text += f"• 检查SSH管理器配置\n"
-                    result_text += f"• 验证Server配置完整性\n"
-                    result_text += f"• 重启MCPServer\n"
-                    
-                    if debug_mode and session_exists:
-                        debug_session_name = f"{session_name}_error_{int(time.time())}"
-                        try:
-                            subprocess.run(['tmux', 'rename-session', '-t', session_name, debug_session_name], 
-                                         capture_output=True)
-                            result_text += f"\n🐛 异常session已保留为: `{debug_session_name}`\n"
-                        except:
-                            pass
-                    
-                    return create_error_response(request_id, result_text)
-                
-                return create_success_response(request_id, result_text)
-                
-            except Exception as e:
-                debug_log(f"Error in establish_connection: {e}")
-                return create_error_response(request_id, f"建立连接失败: {str(e)}")
-        
-        else:
-            return create_error_response(request_id, f"未知工具: {tool_name}", -32601)
             
-    else:
-        response = {
-            "jsonrpc": "2.0",
-            "id": request_id,
-            "error": {
-                "code": -32601,
-                "message": "Method not supported"
-            }
-        }
-        debug_log(f"Error response: {json.dumps(response)}")
-        return response
+        elif method == "tools/run":
+            tool_name = request.get("params", {}).get("name")
+            tool_input = request.get("params", {}).get("input", {})
+            
+            if tool_name == "connect_to_server":
+                server_name = tool_input.get("server_name")
+                # ... (logic for connect_to_server)
+            # ... (other tools)
+            else:
+                return create_error_response(request_id, f"Unknown tool: {tool_name}")
+        else:
+            return create_error_response(request_id, f"Unknown method: {method}", -32601)
+
+    except Exception as e:
+        tb_str = traceback.format_exc()
+        error_msg = f"An unexpected error occurred: {e}\n{tb_str}"
+        debug_log(error_msg)
+        return create_error_response(request_id, error_msg)
 
 async def main():
     """主函数"""
-    debug_log("=" * 50)
-    debug_log("REMOTE TERMINAL MCP SERVER STARTING")
-    debug_log("=" * 50)
-    debug_log(f"Python version: {sys.version}")
-    debug_log(f"Working directory: {os.getcwd()}")
-    debug_log(f"Environment: {dict(os.environ)}")
-    debug_log(f"Script path: {__file__}")
-    debug_log(f"Debug mode: {DEBUG}")
-    debug_log("=" * 50)
-    debug_log("Waiting for MCP requests...")
+    debug_log("MCP server started, waiting for requests...")
+    # 使用更健壮的行读取方式，而不是依赖管道状态
+    reader = asyncio.StreamReader()
+    protocol = asyncio.StreamReaderProtocol(reader)
+    loop = asyncio.get_event_loop()
     
-    while True:
+    # 将标准输入设置为非阻塞
+    if sys.platform != "win32":
+        import os
+        fd = sys.stdin.fileno()
+        os.set_blocking(fd, False)
+
+    await loop.connect_read_pipe(lambda: protocol, sys.stdin)
+
+    while True: # 主循环应该永远运行，直到被外部终止
         try:
-            line = await asyncio.get_event_loop().run_in_executor(None, sys.stdin.readline)
-            if not line:
-                debug_log("No more input, exiting...")
-                break
+            # 持续等待并处理请求
+            header = await reader.readuntil(b'\\r\\n\\r\\n')
+            content_length_header = header.decode('utf-8').split('\\r\\n')[0]
             
-            if line.strip():
-                debug_log(f"RAW INPUT: {line.strip()}")
-                try:
-                    request = json.loads(line.strip())
-                    debug_log(f"PARSED REQUEST: {json.dumps(request, indent=2)}")
-                except json.JSONDecodeError as e:
-                    debug_log(f"JSON DECODE ERROR: {e}")
-                    debug_log(f"Raw line was: {repr(line)}")
-                    continue
-                    
-                response = await handle_request(request)
+            if content_length_header.startswith("Content-Length: "):
+                content_length = int(content_length_header.split(': ')[1])
+                body = await reader.readexactly(content_length)
                 
-                # 只有当有响应时才输出
-                if response is not None:
-                    output = json.dumps(response)
-                    debug_log(f"SENDING RESPONSE: {output}")
-                    print(output, flush=True)
-                else:
-                    debug_log(f"NO RESPONSE GENERATED FOR REQUEST: {request.get('method')}")
-                
-        except Exception as e:
-            debug_log(f"Error processing request: {e}")
+                request = json.loads(body.decode('utf-8'))
+                response = await handle_request(request)
+                if response:
+                    response_body = json.dumps(response).encode('utf-8')
+                    # 确保写回 stdout
+                    sys.stdout.buffer.write(f"Content-Length: {len(response_body)}\\r\\n\\r\\n".encode('utf-8'))
+                    sys.stdout.buffer.write(response_body)
+                    sys.stdout.flush()
+        
+        except asyncio.IncompleteReadError:
+            # 当stdin关闭时，这会是最常见的"错误"，我们应该优雅地退出
+            debug_log("Input stream closed, shutting down.")
+            break
+        except json.JSONDecodeError as e:
+            debug_log(f"JSON decode error: {e}")
+            # 即使解码失败，也应该继续等待下一个请求
             continue
+        except Exception as e:
+            tb_str = traceback.format_exc()
+            debug_log(f"Error in main loop: {e}\\n{tb_str}")
+            # 发生其他错误时，短暂等待后继续，增加稳定性
+            await asyncio.sleep(1)
 
 if __name__ == "__main__":
     try:
         asyncio.run(main())
     except KeyboardInterrupt:
-        debug_log("Received interrupt, exiting...")
-        pass
\ No newline at end of file
+        debug_log("Server stopped by user.")
+    except Exception as e:
+        tb_str = traceback.format_exc()
+        debug_log(f"FATAL error: {e}\n{tb_str}")
+        sys.exit(1)
\ No newline at end of file
