============================= test session starts ==============================
platform darwin -- Python 3.9.6, pytest-8.3.5, pluggy-1.5.0 -- /Applications/Xcode.app/Contents/Developer/usr/bin/python3
cachedir: .pytest_cache
rootdir: /Users/xuyehua/Code/remote-terminal-mcp
plugins: anyio-4.9.0, cov-6.1.1, asyncio-1.0.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 208 items

python/tests/config_manager/test_io.py::TestConfigIO::test_dummy PASSED  [  0%]
python/tests/tool_connect_server/test_connection_manager_integration.py::test_integration_imports PASSED [  0%]
python/tests/tool_connect_server/test_connection_manager_integration.py::test_manager_creation PASSED [  1%]
python/tests/tool_connect_server/test_connection_manager_integration.py::test_api_backward_compatibility PASSED [  1%]
python/tests/tool_connect_server/test_connection_manager_integration.py::test_mcp_server_compatibility PASSED [  2%]
python/tests/tool_connect_server/test_connection_manager_integration.py::test_simple_mode_parameter PASSED [  2%]
python/tests/tool_connect_server/test_end_to_end.py::test_environment PASSED [  3%]
python/tests/tool_connect_server/test_end_to_end.py::TestEndToEndWorkflow::test_complete_server_setup_workflow FAILED [  3%]
python/tests/tool_connect_server/test_end_to_end.py::TestEndToEndWorkflow::test_docker_setup_workflow PASSED [  4%]
python/tests/tool_connect_server/test_end_to_end.py::TestEndToEndWorkflow::test_mcp_integration_workflow FAILED [  4%]
python/tests/tool_connect_server/test_end_to_end.py::TestUserScenarios::test_configuration_migration_scenario FAILED [  5%]
python/tests/tool_connect_server/test_end_to_end.py::TestUserScenarios::test_multiple_servers_scenario PASSED [  5%]
python/tests/tool_connect_server/test_end_to_end.py::TestUserScenarios::test_new_user_setup_scenario FAILED [  6%]
python/tests/tool_connect_server/test_end_to_end.py::TestErrorHandling::test_invalid_config_handling PASSED [  6%]
python/tests/tool_connect_server/test_end_to_end.py::TestErrorHandling::test_permission_error_handling PASSED [  7%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_applescript_terminal_cleanup_integration PASSED [  7%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_complete_applescript_sequence PASSED [  8%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_complete_expect_sequence PASSED [  8%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_comprehensive_test_with_process_management PASSED [  9%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_error_handling_in_process_management PASSED [  9%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_process_cleanup_functionality PASSED [ 10%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_process_tracking_mechanism PASSED [ 10%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_remaining_process_detection PASSED [ 11%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_temp_file_cleanup_integration PASSED [ 11%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_terminal_cleanup_functionality PASSED [ 12%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestCompleteInteractionAndProcessManagement::test_timeout_handling_in_interactions PASSED [ 12%]
python/tests/tool_connect_server/test_fix_complete_interaction_and_process_management_20241222.py::TestInteractionSequenceCompleteness::test_all_required_interaction_steps PASSED [ 12%]
python/tests/tool_connect_server/test_fix_interactive_interface_startup_20241222.py::TestInteractiveInterfaceStartupFix::test_automated_interaction_compatibility PASSED [ 13%]
python/tests/tool_connect_server/test_fix_interactive_interface_startup_20241222.py::TestInteractiveInterfaceStartupFix::test_create_server_config_response_format PASSED [ 13%]
python/tests/tool_connect_server/test_fix_interactive_interface_startup_20241222.py::TestInteractiveInterfaceStartupFix::test_manual_command_execution PASSED [ 14%]
python/tests/tool_connect_server/test_fix_interactive_interface_startup_20241222.py::TestInteractiveInterfaceStartupFix::test_no_background_process_started PASSED [ 14%]
python/tests/tool_connect_server/test_fix_interactive_interface_startup_20241222.py::TestInteractiveInterfaceStartupFix::test_response_consistency PASSED [ 15%]
python/tests/tool_connect_server/test_fix_interactive_interface_startup_20241222.py::TestInteractiveInterfaceStartupFix::test_user_guidance_completeness PASSED [ 15%]
python/tests/tool_connect_server/test_fix_interactive_startup_requirement_20241222.py::TestInteractiveStartupRequirement::test_create_server_config_must_start_interactive_interface FAILED [ 16%]
python/tests/tool_connect_server/test_fix_interactive_startup_requirement_20241222.py::TestInteractiveStartupRequirement::test_interactive_startup_failure_diagnosis FAILED [ 16%]
python/tests/tool_connect_server/test_fix_interactive_startup_requirement_20241222.py::TestInteractiveStartupRequirement::test_interactive_startup_with_minimal_params FAILED [ 17%]
python/tests/tool_connect_server/test_fix_mcp_timeout_issue_20240622.py::TestMCPTimeoutFix::test_reproduce_timeout_issue PASSED [ 17%]
python/tests/tool_connect_server/test_fix_mcp_timeout_issue_20240622.py::TestMCPTimeoutFix::test_verify_timeout_mechanism PASSED [ 18%]
python/tests/tool_connect_server/test_fix_mcp_timeout_issue_20240622.py::TestMCPTimeoutFix::test_timeout_parameter_validation PASSED [ 18%]
python/tests/tool_connect_server/test_fix_mcp_timeout_issue_20240622.py::TestMCPTimeoutFix::test_process_cleanup_after_timeout PASSED [ 19%]
python/tests/tool_connect_server/test_fix_mcp_timeout_issue_20240622.py::TestMCPTimeoutFix::test_normal_operation_with_timeout PASSED [ 19%]
python/tests/tool_connect_server/test_fix_mcp_timeout_issue_20240622.py::TestMCPTimeoutFix::test_different_tools_timeout_behavior PASSED [ 20%]
python/tests/tool_connect_server/test_fix_mcp_timeout_issue_20240622.py::TestMCPTimeoutFix::test_timeout_fix_documentation PASSED [ 20%]
python/tests/tool_connect_server/test_fix_relay_cli_usage_20250105.py::TestRelayCLIUsageCompliance::test_code_examples_in_documentation PASSED [ 21%]
python/tests/tool_connect_server/test_fix_relay_cli_usage_20250105.py::TestRelayCLIUsageCompliance::test_correct_relay_cli_usage PASSED [ 21%]
python/tests/tool_connect_server/test_fix_relay_cli_usage_20250105.py::TestRelayCLIUsageCompliance::test_edge_cases PASSED [ 22%]
python/tests/tool_connect_server/test_fix_relay_cli_usage_20250105.py::TestRelayCLIUsageCompliance::test_forbidden_relay_cli_usage PASSED [ 22%]
python/tests/tool_connect_server/test_fix_relay_cli_usage_20250105.py::TestRelayCLIUsageCompliance::test_parse_relay_cli_command PASSED [ 23%]
python/tests/tool_connect_server/test_fix_relay_cli_usage_20250105.py::TestRelayCLIUsageCompliance::test_rule_documentation_compliance PASSED [ 23%]
python/tests/tool_connect_server/test_fix_relay_cli_usage_20250105.py::TestRelayCLIRegressionPrevention::test_correct_usage_still_works PASSED [ 24%]
python/tests/tool_connect_server/test_fix_relay_cli_usage_20250105.py::TestRelayCLIRegressionPrevention::test_prevent_command_parameter_regression PASSED [ 24%]
python/tests/tool_connect_server/test_fix_relay_connection_logic_20250105.py::TestRelayConnectionLogicFix::test_all_fixes_integration PASSED [ 25%]
python/tests/tool_connect_server/test_fix_relay_connection_logic_20250105.py::TestRelayConnectionLogicFix::test_command_execution_enhanced PASSED [ 25%]
python/tests/tool_connect_server/test_fix_relay_connection_logic_20250105.py::TestRelayConnectionLogicFix::test_connection_detection_enhanced PASSED [ 25%]
python/tests/tool_connect_server/test_fix_relay_connection_logic_20250105.py::TestRelayConnectionLogicFix::test_connection_error_logging_enhanced PASSED [ 26%]
python/tests/tool_connect_server/test_fix_relay_connection_logic_20250105.py::TestRelayConnectionLogicFix::test_interactive_guide_relay_patterns PASSED [ 26%]
python/tests/tool_connect_server/test_fix_relay_connection_logic_20250105.py::TestRelayConnectionLogicFix::test_relay_authentication_handler_added PASSED [ 27%]
python/tests/tool_connect_server/test_fix_relay_connection_logic_20250105.py::TestRelayConnectionLogicFix::test_relay_cli_usage_compliance PASSED [ 27%]
python/tests/tool_connect_server/test_fix_relay_connection_logic_20250105.py::TestRelayConnectionSpecific::test_relay_authentication_success_detection PASSED [ 28%]
python/tests/tool_connect_server/test_fix_relay_connection_logic_20250105.py::TestRelayConnectionSpecific::test_relay_authentication_timeout_handling PASSED [ 28%]
python/tests/tool_connect_server/test_fix_tj09_server_creation_20240622.py::TJ09ServerCreationTest::test_tj09_connection_type PASSED [ 29%]
python/tests/tool_connect_server/test_fix_tj09_server_creation_20240622.py::TJ09ServerCreationTest::test_tj09_docker_config PASSED [ 29%]
python/tests/tool_connect_server/test_fix_tj09_server_creation_20240622.py::TJ09ServerCreationTest::test_tj09_server_config PASSED [ 30%]
python/tests/tool_connect_server/test_fix_tj09_server_creation_20240622.py::TJ09ServerCreationTest::test_tj09_server_exists PASSED [ 30%]
python/tests/tool_connect_server/test_fix_tj09_server_creation_20240622.py::TJ09ServerCreationTest::test_tj09_status_check PASSED [ 31%]
python/tests/tool_connect_server/test_fix_user_visible_interaction_20241222.py::TestUserVisibleInteraction::test_background_process_detection PASSED [ 31%]
python/tests/tool_connect_server/test_fix_user_visible_interaction_20241222.py::TestUserVisibleInteraction::test_interactive_interface_accessibility FAILED [ 32%]
python/tests/tool_connect_server/test_fix_user_visible_interaction_20241222.py::TestUserVisibleInteraction::test_process_output_visibility PASSED [ 32%]
python/tests/tool_connect_server/test_fix_user_visible_interaction_20241222.py::TestUserVisibleInteraction::test_terminal_window_creation_on_macos FAILED [ 33%]
python/tests/tool_connect_server/test_fully_automated_interactive.py::TestFullyAutomatedInteractive::test_guided_setup_docker_server_full_automation FAILED [ 33%]
python/tests/tool_connect_server/test_fully_automated_interactive.py::TestFullyAutomatedInteractive::test_guided_setup_relay_server_full_automation FAILED [ 34%]
python/tests/tool_connect_server/test_fully_automated_interactive.py::TestFullyAutomatedInteractive::test_guided_setup_ssh_server_full_automation FAILED [ 34%]
python/tests/tool_connect_server/test_fully_automated_interactive.py::TestFullyAutomatedInteractive::test_main_menu_automation PASSED [ 35%]
python/tests/tool_connect_server/test_fully_automated_interactive.py::TestFullyAutomatedInteractive::test_smart_input_error_recovery_automation FAILED [ 35%]
python/tests/tool_connect_server/test_fully_automated_interactive.py::TestInputValidationAutomation::test_hostname_validation_automation FAILED [ 36%]
python/tests/tool_connect_server/test_fully_automated_interactive.py::TestInputValidationAutomation::test_port_validation_automation FAILED [ 36%]
python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_config_file_operations FAILED [ 37%]
python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_config_manager_tools FAILED [ 37%]
python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_docker_command_generation FAILED [ 37%]
python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_docker_config_tools PASSED [ 38%]
python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_mcp_server_import PASSED [ 38%]
python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_mcp_tool_availability PASSED [ 39%]
python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_server_config_creation FAILED [ 39%]
python/tests/tool_connect_server/test_mcp_tools.py::TestConfigurationConsistency::test_config_directory_consistency FAILED [ 40%]
python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_dependencies_installable FAILED [ 40%]
python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_main_entry_file FAILED [ 41%]
python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_package_json_exists FAILED [ 41%]
python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_package_json_structure FAILED [ 42%]
python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_required_python_files FAILED [ 42%]
python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_scripts_configuration FAILED [ 43%]
python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageInstallation::test_npm_pack_success FAILED [ 43%]
python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageInstallation::test_package_size_reasonable PASSED [ 44%]
python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackagePublishing::test_npm_publish_dry_run PASSED [ 44%]
python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackagePublishing::test_version_consistency FAILED [ 45%]
python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationRegression::test_config_directory_consistency FAILED [ 45%]
python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationRegression::test_config_file_structure FAILED [ 46%]
python/tests/tool_connect_server/test_regression_prevention.py::TestMCPToolsRegression::test_interactive_wizard_functionality FAILED [ 46%]
python/tests/tool_connect_server/test_regression_prevention.py::TestMCPToolsRegression::test_mcp_tools_availability PASSED [ 47%]
python/tests/tool_connect_server/test_regression_prevention.py::TestDockerConfigRegression::test_docker_command_completeness FAILED [ 47%]
python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationPersistenceRegression::test_ensure_config_exists_preserves_user_config FAILED [ 48%]
python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationPersistenceRegression::test_get_existing_servers_preserves_user_modifications FAILED [ 48%]
python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationPersistenceRegression::test_modified_example_server_detection FAILED [ 49%]
python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationPersistenceRegression::test_npm_installation_protection FAILED [ 49%]
python/tests/tool_connect_server/test_regression_prevention.py::TestUserExperienceRegression::test_configuration_backup FAILED [ 50%]
python/tests/tool_connect_server/test_regression_prevention.py::TestUserExperienceRegression::test_error_messages_quality FAILED [ 50%]
python/tests/tool_connect_server/test_regression_prevention.py::TestAPIConsistency::test_docker_config_manager_api FAILED [ 50%]
python/tests/tool_connect_server/test_regression_prevention.py::TestAPIConsistency::test_enhanced_config_manager_api FAILED [ 51%]
python/tests/tool_connect_server/test_simple_automated_demo.py::TestSimpleAutomationDemo::test_mcp_guided_setup_automation FAILED [ 51%]
python/tests/tool_connect_server/test_simple_automated_demo.py::TestSimpleAutomationDemo::test_multiple_validation_types FAILED [ 52%]
python/tests/tool_connect_server/test_simple_automated_demo.py::TestSimpleAutomationDemo::test_smart_input_basic_automation FAILED [ 52%]
python/tests/tool_connect_server/test_simple_automated_demo.py::TestSimpleAutomationDemo::test_smart_input_error_recovery_automation FAILED [ 53%]
python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_batch_server_creation FAILED [ 53%]
python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_completely_headless_operation FAILED [ 54%]
python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_completely_silent_mcp_setup FAILED [ 54%]
python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_mock_all_interactions_completely FAILED [ 55%]
python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_smart_input_with_defaults FAILED [ 55%]
python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_validation_with_auto_retry FAILED [ 56%]

=================================== FAILURES ===================================
___________ TestEndToEndWorkflow.test_complete_server_setup_workflow ___________

self = <python.tests.tool_connect_server.test_end_to_end.TestEndToEndWorkflow testMethod=test_complete_server_setup_workflow>

    def test_complete_server_setup_workflow(self):
        """测试完整的服务器设置工作流程"""
        with test_environment() as env:
            # 1. 创建配置管理器
            from config_manager.main import EnhancedConfigManager
    
            config_manager = EnhancedConfigManager()
    
            # 2. 创建服务器配置
            server_config = {
                'name': 'integration-test-server',
                'host': '192.168.1.100',
                'username': 'testuser',
                'port': 22,
                'connection_type': 'ssh',
                'description': '集成测试服务器'
            }
    
            # 3. 测试获取现有服务器配置
            try:
                result = config_manager.list_servers()
                self.assertIsNotNone(result, "获取现有服务器配置应该成功")
            except Exception as e:
                self.fail(f"获取服务器配置失败: {e}")
    
            # 4. 验证配置文件结构
>           config_dir = config_manager.io.config_path.parent
E           AttributeError: 'EnhancedConfigManager' object has no attribute 'io'

python/tests/tool_connect_server/test_end_to_end.py:60: AttributeError
______________ TestEndToEndWorkflow.test_mcp_integration_workflow ______________

self = <python.tests.tool_connect_server.test_end_to_end.TestEndToEndWorkflow testMethod=test_mcp_integration_workflow>

    def test_mcp_integration_workflow(self):
        """测试MCP集成工作流程"""
        try:
            # 1. 导入MCP服务器模块
            import mcp_server
    
            # 2. 测试工具列表创建
            tools = mcp_server.create_tools_list()
            self.assertIsNotNone(tools, "MCP工具列表创建成功")
            self.assertGreater(len(tools), 0, "应该有可用的MCP工具")
    
            # 3. 测试配置管理器集成
            from config_manager.main import EnhancedConfigManager
            config_manager = EnhancedConfigManager()
    
            # 4. 验证配置目录一致性
>           config_path = config_manager.io.config_path
E           AttributeError: 'EnhancedConfigManager' object has no attribute 'io'

python/tests/tool_connect_server/test_end_to_end.py:115: AttributeError

During handling of the above exception, another exception occurred:

self = <python.tests.tool_connect_server.test_end_to_end.TestEndToEndWorkflow testMethod=test_mcp_integration_workflow>

    def test_mcp_integration_workflow(self):
        """测试MCP集成工作流程"""
        try:
            # 1. 导入MCP服务器模块
            import mcp_server
    
            # 2. 测试工具列表创建
            tools = mcp_server.create_tools_list()
            self.assertIsNotNone(tools, "MCP工具列表创建成功")
            self.assertGreater(len(tools), 0, "应该有可用的MCP工具")
    
            # 3. 测试配置管理器集成
            from config_manager.main import EnhancedConfigManager
            config_manager = EnhancedConfigManager()
    
            # 4. 验证配置目录一致性
            config_path = config_manager.io.config_path
            self.assertTrue(str(config_path).endswith('.remote-terminal/config.yaml'),
                           "MCP集成应该使用正确的配置目录")
    
        except Exception as e:
>           self.fail(f"MCP集成工作流程失败: {e}")
E           AssertionError: MCP集成工作流程失败: 'EnhancedConfigManager' object has no attribute 'io'

python/tests/tool_connect_server/test_end_to_end.py:120: AssertionError
___________ TestUserScenarios.test_configuration_migration_scenario ____________

self = <python.tests.tool_connect_server.test_end_to_end.TestUserScenarios testMethod=test_configuration_migration_scenario>

    def test_configuration_migration_scenario(self):
        """测试配置迁移场景"""
        with test_environment() as env:
            # 模拟从旧配置目录迁移的场景
            from config_manager.main import EnhancedConfigManager
    
            config_manager = EnhancedConfigManager()
>           correct_config_dir = config_manager.io.config_path.parent
E           AttributeError: 'EnhancedConfigManager' object has no attribute 'io'

python/tests/tool_connect_server/test_end_to_end.py:235: AttributeError
________________ TestUserScenarios.test_new_user_setup_scenario ________________

self = <python.tests.tool_connect_server.test_end_to_end.TestUserScenarios testMethod=test_new_user_setup_scenario>

    def test_new_user_setup_scenario(self):
        """测试新用户设置场景"""
        with test_environment() as env:
            # 模拟新用户首次使用
            from config_manager.main import EnhancedConfigManager
    
            config_manager = EnhancedConfigManager()
    
            # 1. 检查配置目录不存在时的行为
>           config_dir = config_manager.io.config_path.parent
E           AttributeError: 'EnhancedConfigManager' object has no attribute 'io'

python/tests/tool_connect_server/test_end_to_end.py:148: AttributeError
_ TestInteractiveStartupRequirement.test_create_server_config_must_start_interactive_interface _

self = <python.tests.tool_connect_server.test_fix_interactive_startup_requirement_20241222.TestInteractiveStartupRequirement testMethod=test_create_server_config_must_start_interactive_interface>

    def test_create_server_config_must_start_interactive_interface(self):
        """
        核心测试：create_server_config工具必须启动交互配置界面
    
        测试步骤：
        1. 准备测试参数
        2. 调用launch_cursor_terminal_config方法
        3. 验证返回结果表明成功启动（而不是提供手动命令）
        4. 验证进程确实在运行
        5. 验证预填充文件存在且内容正确
        """
        print("\n🎯 开始测试：create_server_config必须启动交互配置界面")
    
        # 第1步：准备测试参数
        test_params = {
            'name': 'test_interactive_startup',
            'host': 'test.example.com',
            'username': 'testuser',
            'port': 22,
            'connection_type': 'relay',
            'description': '测试交互启动功能',
            'docker_enabled': True,
            'docker_image': 'ubuntu:20.04',
            'docker_container': 'test_container'
        }
    
        print(f"📋 测试参数: {json.dumps(test_params, ensure_ascii=False, indent=2)}")
    
        # 第2步：调用配置管理器的启动方法
        print("🚀 调用launch_cursor_terminal_config方法...")
        try:
            result = self.config_manager.launch_cursor_terminal_config(prefill_params=test_params)
            print(f"📄 返回结果: {json.dumps(result, ensure_ascii=False, indent=2)}")
        except Exception as e:
            self.fail(f"❌ 调用launch_cursor_terminal_config失败: {e}")
    
        # 第3步：验证返回结果表明成功启动
        print("🔍 验证返回结果...")
    
        # 必须返回成功状态
>       self.assertTrue(result.get('success'),
                       f"❌ 期望返回success=True，实际得到: {result.get('success')}")
E       AttributeError: 'NoneType' object has no attribute 'get'

python/tests/tool_connect_server/test_fix_interactive_startup_requirement_20241222.py:112: AttributeError
----------------------------- Captured stdout call -----------------------------

🎯 开始测试：create_server_config必须启动交互配置界面
📋 测试参数: {
  "name": "test_interactive_startup",
  "host": "test.example.com",
  "username": "testuser",
  "port": 22,
  "connection_type": "relay",
  "description": "测试交互启动功能",
  "docker_enabled": true,
  "docker_image": "ubuntu:20.04",
  "docker_container": "test_container"
}
🚀 调用launch_cursor_terminal_config方法...
📄 返回结果: null
🔍 验证返回结果...
_ TestInteractiveStartupRequirement.test_interactive_startup_failure_diagnosis _

self = <python.tests.tool_connect_server.test_fix_interactive_startup_requirement_20241222.TestInteractiveStartupRequirement testMethod=test_interactive_startup_failure_diagnosis>

    def test_interactive_startup_failure_diagnosis(self):
        """测试启动失败时的诊断信息"""
        print("\n🎯 开始测试：启动失败诊断")
    
        # 尝试使用无效参数（这可能不会导致失败，但我们测试错误处理）
        invalid_params = {
            'name': '',  # 空名称
            'host': '',  # 空主机
            'username': ''  # 空用户名
        }
    
        result = self.config_manager.launch_cursor_terminal_config(prefill_params=invalid_params)
    
        # 即使参数无效，启动机制本身应该工作
        # 如果失败，应该有详细的错误信息
>       if not result.get('success'):
E       AttributeError: 'NoneType' object has no attribute 'get'

python/tests/tool_connect_server/test_fix_interactive_startup_requirement_20241222.py:237: AttributeError
----------------------------- Captured stdout call -----------------------------

🎯 开始测试：启动失败诊断
_ TestInteractiveStartupRequirement.test_interactive_startup_with_minimal_params _

self = <python.tests.tool_connect_server.test_fix_interactive_startup_requirement_20241222.TestInteractiveStartupRequirement testMethod=test_interactive_startup_with_minimal_params>

    def test_interactive_startup_with_minimal_params(self):
        """测试最小参数下的交互启动"""
        print("\n🎯 开始测试：最小参数下的交互启动")
    
        minimal_params = {
            'name': 'test_minimal',
            'host': 'minimal.test.com',
            'username': 'minimal_user'
        }
    
        result = self.config_manager.launch_cursor_terminal_config(prefill_params=minimal_params)
    
        # 验证基本成功条件
>       self.assertTrue(result.get('success'), "最小参数测试失败")
E       AttributeError: 'NoneType' object has no attribute 'get'

python/tests/tool_connect_server/test_fix_interactive_startup_requirement_20241222.py:210: AttributeError
----------------------------- Captured stdout call -----------------------------

🎯 开始测试：最小参数下的交互启动
_____ TestUserVisibleInteraction.test_interactive_interface_accessibility ______

self = <python.tests.tool_connect_server.test_fix_user_visible_interaction_20241222.TestUserVisibleInteraction testMethod=test_interactive_interface_accessibility>

    def test_interactive_interface_accessibility(self):
        """
        测试交互界面是否可访问（用户能否与之交互）
        """
        print("\n🎯 测试交互界面可访问性")
    
        # 这个测试检查的是：启动的进程是否能接受用户输入
        test_params = {
            'name': 'test_accessibility',
            'host': 'access.test.com',
            'username': 'access_user'
        }
    
        result = self.config_manager.launch_cursor_terminal_config(prefill_params=test_params)
    
        # 记录文件用于清理
>       if result.get('prefill_file'):
E       AttributeError: 'NoneType' object has no attribute 'get'

python/tests/tool_connect_server/test_fix_user_visible_interaction_20241222.py:204: AttributeError
----------------------------- Captured stdout call -----------------------------

🎯 测试交互界面可访问性
______ TestUserVisibleInteraction.test_terminal_window_creation_on_macos _______

self = <python.tests.tool_connect_server.test_fix_user_visible_interaction_20241222.TestUserVisibleInteraction testMethod=test_terminal_window_creation_on_macos>

    def test_terminal_window_creation_on_macos(self):
        """
        测试在macOS上是否真的创建了新的Terminal窗口
        """
        print("\n🎯 测试Terminal窗口创建（macOS）")
    
        # 只在macOS上运行这个测试
        import platform
        if platform.system() != "Darwin":
            self.skipTest("此测试仅适用于macOS")
    
        # 记录启动前的Terminal窗口数量
        try:
            result = subprocess.run([
                "osascript", "-e",
                'tell application "Terminal" to count windows'
            ], capture_output=True, text=True, timeout=5)
    
            if result.returncode == 0:
                windows_before = int(result.stdout.strip())
                print(f"📊 启动前Terminal窗口数: {windows_before}")
            else:
                windows_before = 0
                print("⚠️ 无法获取Terminal窗口数，假设为0")
    
        except Exception as e:
            windows_before = 0
            print(f"⚠️ 检查Terminal窗口失败: {e}")
    
        # 启动配置界面
        test_params = {
            'name': 'test_terminal_window',
            'host': 'terminal.test.com',
            'username': 'terminal_user'
        }
    
        result = self.config_manager.launch_cursor_terminal_config(prefill_params=test_params)
    
        # 记录文件用于清理
>       if result.get('prefill_file'):
E       AttributeError: 'NoneType' object has no attribute 'get'

python/tests/tool_connect_server/test_fix_user_visible_interaction_20241222.py:109: AttributeError
----------------------------- Captured stdout call -----------------------------

🎯 测试Terminal窗口创建（macOS）
📊 启动前Terminal窗口数: 1
_ TestFullyAutomatedInteractive.test_guided_setup_docker_server_full_automation _

self = <python.tests.tool_connect_server.test_fully_automated_interactive.TestFullyAutomatedInteractive testMethod=test_guided_setup_docker_server_full_automation>

    def test_guided_setup_docker_server_full_automation(self):
        """测试完全自动化的Docker服务器配置"""
        # 模拟用户输入序列（包含Docker配置）
        user_inputs = [
            '1',                    # 选择引导配置
            'test-docker-server',   # 服务器名称
            '192.168.1.101',        # 服务器地址
            'dockeruser',           # 用户名
            '2222',                 # SSH端口
            '1',                    # 选择SSH连接类型
            'Test Docker Server',   # 服务器描述
            'y',                    # 启用Docker
            'ubuntu:22.04',         # Docker镜像
            'test-container',       # 容器名称
            'y',                    # 自动创建容器
            'y'                     # 确认保存配置
        ]
        all_inputs = itertools.chain(user_inputs, itertools.repeat('22'))
        def input_side_effect(prompt):
            if "端口" in str(prompt) or "port" in str(prompt):
                return "22"
            try:
                return next(all_inputs)
            except StopIteration:
                return ""
        with patch('builtins.input', side_effect=input_side_effect):
            with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                result = self.config_manager.guided_setup()
    
        # 验证配置成功
        self.assertTrue(result, "Docker引导配置应该成功")
    
        # 验证配置文件内容
        with open(self.config_file, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
    
>       server_config = config['servers']['test-docker-server']
E       KeyError: 'test-docker-server'

python/tests/tool_connect_server/test_fully_automated_interactive.py:123: KeyError
_ TestFullyAutomatedInteractive.test_guided_setup_relay_server_full_automation _

self = <python.tests.tool_connect_server.test_fully_automated_interactive.TestFullyAutomatedInteractive testMethod=test_guided_setup_relay_server_full_automation>

    def test_guided_setup_relay_server_full_automation(self):
        """测试完全自动化的Relay服务器配置"""
        # 模拟用户输入序列（Relay连接）
        user_inputs = [
            '1',                        # 选择引导配置
            'test-relay-server',        # 服务器名称
            'internal.server.com',      # 服务器地址
            'relayuser',                # 用户名
            '22',                       # SSH端口
            '2',                        # 选择Relay连接类型
            'internal.server.com',      # Relay目标主机
            'Test Relay Server',        # 服务器描述
            'n',                        # 不启用Docker
            'y'                         # 确认保存配置
        ]
        all_inputs = itertools.chain(user_inputs, itertools.repeat('22'))
        def input_side_effect(prompt):
            if "端口" in str(prompt) or "port" in str(prompt):
                return "22"
            try:
                return next(all_inputs)
            except StopIteration:
                return ""
        with patch('builtins.input', side_effect=input_side_effect):
            with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                result = self.config_manager.guided_setup()
    
        # 验证配置成功
        self.assertTrue(result, "Relay引导配置应该成功")
    
        # 验证配置文件内容
        with open(self.config_file, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
    
>       server_config = config['servers']['test-relay-server']
E       KeyError: 'test-relay-server'

python/tests/tool_connect_server/test_fully_automated_interactive.py:171: KeyError
__ TestFullyAutomatedInteractive.test_guided_setup_ssh_server_full_automation __

self = <python.tests.tool_connect_server.test_fully_automated_interactive.TestFullyAutomatedInteractive testMethod=test_guided_setup_ssh_server_full_automation>

    def test_guided_setup_ssh_server_full_automation(self):
        """测试完全自动化的SSH服务器配置"""
        # 模拟用户输入序列
        user_inputs = [
            '1',                    # 选择引导配置
            'test-ssh-server',      # 服务器名称
            '192.168.1.100',        # 服务器地址
            'testuser',             # 用户名
            '22',                   # SSH端口
            '1',                    # 选择SSH连接类型
            'Test SSH Server',      # 服务器描述
            'n',                    # 不启用Docker
            'y'                     # 确认保存配置
        ]
        all_inputs = itertools.chain(user_inputs, itertools.repeat('22'))
        def input_side_effect(prompt):
            if "端口" in str(prompt) or "port" in str(prompt):
                return "22"
            try:
                return next(all_inputs)
            except StopIteration:
                return ""
        with patch('builtins.input', side_effect=input_side_effect):
            with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                result = self.config_manager.guided_setup()
    
        # 验证配置成功
        self.assertTrue(result, "引导配置应该成功")
    
        # 验证配置文件内容
        self.assertTrue(self.config_file.exists(), "配置文件应该被创建")
    
        with open(self.config_file, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
    
        self.assertIn('servers', config)
>       self.assertIn('test-ssh-server', config['servers'])
E       AssertionError: 'test-ssh-server' not found in {'test_server': {}}

python/tests/tool_connect_server/test_fully_automated_interactive.py:78: AssertionError
___ TestFullyAutomatedInteractive.test_smart_input_error_recovery_automation ___

self = <python.tests.tool_connect_server.test_fully_automated_interactive.TestFullyAutomatedInteractive testMethod=test_smart_input_error_recovery_automation>

    def test_smart_input_error_recovery_automation(self):
        """测试智能输入的错误恢复自动化"""
        # 模拟用户输入错误然后纠正的场景
        user_inputs = [
            '1',                        # 选择引导配置
            'test-error-recovery',      # 服务器名称
            'invalid host with spaces', # 无效的服务器地址（第一次）
            '192.168.1.102',            # 正确的服务器地址（第二次）
            'a',                        # 无效的用户名（太短）
            'validuser',                # 正确的用户名
            '99999',                    # 无效的端口号
            '22',                       # 正确的端口号
            '1',                        # 选择SSH连接类型
            'Error Recovery Test',      # 服务器描述
            'n',                        # 不启用Docker
            'y'                         # 确认保存配置
        ]
        all_inputs = itertools.chain(user_inputs, itertools.repeat('22'))
        def input_side_effect(prompt):
            if "端口" in str(prompt) or "port" in str(prompt):
                return "22"
            try:
                return next(all_inputs)
            except StopIteration:
                return ""
        with patch('builtins.input', side_effect=input_side_effect):
            with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                result = self.config_manager.guided_setup()
                output = mock_stdout.getvalue()
    
        # 验证配置最终成功
        self.assertTrue(result, "错误恢复后的配置应该成功")
    
        # 验证错误提示出现在输出中
>       self.assertIn('输入验证失败', output)
E       AssertionError: '输入验证失败' not found in ''

python/tests/tool_connect_server/test_fully_automated_interactive.py:217: AssertionError
______ TestInputValidationAutomation.test_hostname_validation_automation _______

self = <python.tests.tool_connect_server.test_fully_automated_interactive.TestInputValidationAutomation testMethod=test_hostname_validation_automation>

    def test_hostname_validation_automation(self):
        """测试主机名验证的自动化"""
        # 测试各种无效输入然后提供有效输入
        invalid_then_valid_inputs = [
            'invalid host',         # 包含空格
            '192.168.1.999',        # 无效IP
            'host..invalid',        # 双点
            'valid-host.com'        # 有效主机名
        ]
    
        def input_side_effect(prompt):
            if "端口" in str(prompt) or "port" in str(prompt):
                return "22"
            try:
                return next(iter(invalid_then_valid_inputs))
            except StopIteration:
                return ""
        inputs_iter = iter(invalid_then_valid_inputs)
        with patch('builtins.input', side_effect=input_side_effect), \
             patch.object(UserInteraction, 'smart_input', side_effect=input_side_effect):
            result = self.config_manager.smart_input(
                "🌐 服务器地址",
                validator=self.config_manager.validate_hostname
            )
>           output = mock_stdout.getvalue()
E           NameError: name 'mock_stdout' is not defined

python/tests/tool_connect_server/test_fully_automated_interactive.py:275: NameError
----------------------------- Captured stdout call -----------------------------
输入验证失败：服务器地址不能包含空格。正确格式示例：192.168.1.100
________ TestInputValidationAutomation.test_port_validation_automation _________

self = <python.tests.tool_connect_server.test_fully_automated_interactive.TestInputValidationAutomation testMethod=test_port_validation_automation>

    def test_port_validation_automation(self):
        """测试端口验证的自动化"""
        invalid_then_valid_inputs = [
            '0',            # 端口号太小
            '99999',        # 端口号太大
            'abc',          # 非数字
            '22'            # 有效端口
        ]
    
        def input_side_effect(prompt):
            if "端口" in str(prompt) or "port" in str(prompt):
                return "22"
            try:
                return next(iter(invalid_then_valid_inputs))
            except StopIteration:
                return ""
        inputs_iter = iter(invalid_then_valid_inputs)
        with patch('builtins.input', side_effect=input_side_effect), \
             patch.object(UserInteraction, 'smart_input', side_effect=input_side_effect):
            result = self.config_manager.smart_input(
                "🔌 SSH端口",
                validator=self.config_manager.validate_port
            )
>           output = mock_stdout.getvalue()
E           NameError: name 'mock_stdout' is not defined

python/tests/tool_connect_server/test_fully_automated_interactive.py:304: NameError
----------------------------- Captured stdout call -----------------------------
输入验证失败：服务器地址不能包含空格。正确格式示例：192.168.1.100
___________________ TestMCPTools.test_config_file_operations ___________________

self = <python.tests.tool_connect_server.test_mcp_tools.TestMCPTools testMethod=test_config_file_operations>

    def test_config_file_operations(self):
        """测试配置文件操作"""
        from config_manager.main import EnhancedConfigManager
    
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_mcp_tools.py:102: UnboundLocalError
____________________ TestMCPTools.test_config_manager_tools ____________________

self = <python.tests.tool_connect_server.test_mcp_tools.TestMCPTools testMethod=test_config_manager_tools>

    def test_config_manager_tools(self):
        """测试配置管理工具"""
        from config_manager.main import EnhancedConfigManager
    
        # 使用临时配置目录
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_mcp_tools.py:34: UnboundLocalError
_________________ TestMCPTools.test_docker_command_generation __________________

self = <python.tests.tool_connect_server.test_mcp_tools.TestMCPTools testMethod=test_docker_command_generation>

    def test_docker_command_generation(self):
        """测试Docker命令生成"""
        from config_manager.main import EnhancedConfigManager
    
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_mcp_tools.py:88: UnboundLocalError
___________________ TestMCPTools.test_server_config_creation ___________________

self = <python.tests.tool_connect_server.test_mcp_tools.TestMCPTools testMethod=test_server_config_creation>

    def test_server_config_creation(self):
        """测试服务器配置创建"""
        from config_manager.main import EnhancedConfigManager
    
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_mcp_tools.py:66: UnboundLocalError
________ TestConfigurationConsistency.test_config_directory_consistency ________

self = <python.tests.tool_connect_server.test_mcp_tools.TestConfigurationConsistency testMethod=test_config_directory_consistency>

    def test_config_directory_consistency(self):
        """测试配置目录一致性"""
        from config_manager.main import EnhancedConfigManager
        from docker_config_manager import DockerConfigManager
    
>       enhanced_manager = config_manager.main.EnhancedConfigManager()
E       NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_mcp_tools.py:145: NameError
____________ TestNPMPackageIntegrity.test_dependencies_installable _____________

self = <python.tests.tool_connect_server.test_package_integrity.TestNPMPackageIntegrity testMethod=test_dependencies_installable>

    def test_dependencies_installable(self):
        """测试依赖项可安装性"""
>       with open(self.package_json_path) as f:
E       FileNotFoundError: [Errno 2] No such file or directory: '/Users/xuyehua/Code/remote-terminal-mcp/python/package.json'

python/tests/tool_connect_server/test_package_integrity.py:79: FileNotFoundError
_________________ TestNPMPackageIntegrity.test_main_entry_file _________________

self = <python.tests.tool_connect_server.test_package_integrity.TestNPMPackageIntegrity testMethod=test_main_entry_file>

    def test_main_entry_file(self):
        """测试主入口文件"""
>       with open(self.package_json_path) as f:
E       FileNotFoundError: [Errno 2] No such file or directory: '/Users/xuyehua/Code/remote-terminal-mcp/python/package.json'

python/tests/tool_connect_server/test_package_integrity.py:51: FileNotFoundError
_______________ TestNPMPackageIntegrity.test_package_json_exists _______________

self = <python.tests.tool_connect_server.test_package_integrity.TestNPMPackageIntegrity testMethod=test_package_json_exists>

    def test_package_json_exists(self):
        """测试package.json文件存在"""
>       self.assertTrue(self.package_json_path.exists(),
                       "package.json文件必须存在")
E       AssertionError: False is not true : package.json文件必须存在

python/tests/tool_connect_server/test_package_integrity.py:27: AssertionError
_____________ TestNPMPackageIntegrity.test_package_json_structure ______________

self = <python.tests.tool_connect_server.test_package_integrity.TestNPMPackageIntegrity testMethod=test_package_json_structure>

    def test_package_json_structure(self):
        """测试package.json结构完整性"""
>       with open(self.package_json_path) as f:
E       FileNotFoundError: [Errno 2] No such file or directory: '/Users/xuyehua/Code/remote-terminal-mcp/python/package.json'

python/tests/tool_connect_server/test_package_integrity.py:32: FileNotFoundError
______________ TestNPMPackageIntegrity.test_required_python_files ______________

self = <python.tests.tool_connect_server.test_package_integrity.TestNPMPackageIntegrity testMethod=test_required_python_files>

    def test_required_python_files(self):
        """测试必要的Python文件"""
        required_files = [
            'enhanced_config_manager.py',
            'docker_config_manager.py',
            'python/mcp_server.py'
        ]
    
        for file_path in required_files:
            full_path = self.project_root / file_path
>           self.assertTrue(full_path.exists(),
                           f"必要文件{file_path}必须存在")
E           AssertionError: False is not true : 必要文件enhanced_config_manager.py必须存在

python/tests/tool_connect_server/test_package_integrity.py:74: AssertionError
______________ TestNPMPackageIntegrity.test_scripts_configuration ______________

self = <python.tests.tool_connect_server.test_package_integrity.TestNPMPackageIntegrity testMethod=test_scripts_configuration>

    def test_scripts_configuration(self):
        """测试脚本配置"""
>       with open(self.package_json_path) as f:
E       FileNotFoundError: [Errno 2] No such file or directory: '/Users/xuyehua/Code/remote-terminal-mcp/python/package.json'

python/tests/tool_connect_server/test_package_integrity.py:91: FileNotFoundError
_______________ TestNPMPackageInstallation.test_npm_pack_success _______________

self = <python.tests.tool_connect_server.test_package_integrity.TestNPMPackageInstallation testMethod=test_npm_pack_success>

    def test_npm_pack_success(self):
        """测试npm pack成功"""
        try:
            result = run_command(['npm', 'pack'],
                                cwd=self.project_root, timeout=60)
    
>           self.assertEqual(result.returncode, 0,
                           f"npm pack失败: {result.stderr}")
E                          AssertionError: 254 != 0 : npm pack失败: npm error code ENOENT
E                          npm error syscall open
E                          npm error path /Users/xuyehua/Code/remote-terminal-mcp/python/package.json
E                          npm error errno -2
E                          npm error enoent Could not read package.json: Error: ENOENT: no such file or directory, open '/Users/xuyehua/Code/remote-terminal-mcp/python/package.json'
E                          npm error enoent This is related to npm not being able to find a file.
E                          npm error enoent
E                          npm error A complete log of this run can be found in: /Users/xuyehua/.npm/_logs/2025-07-16T16_05_14_995Z-debug-0.log

python/tests/tool_connect_server/test_package_integrity.py:117: AssertionError

During handling of the above exception, another exception occurred:

self = <python.tests.tool_connect_server.test_package_integrity.TestNPMPackageInstallation testMethod=test_npm_pack_success>

    def test_npm_pack_success(self):
        """测试npm pack成功"""
        try:
            result = run_command(['npm', 'pack'],
                                cwd=self.project_root, timeout=60)
    
            self.assertEqual(result.returncode, 0,
                           f"npm pack失败: {result.stderr}")
    
            # npm pack会生成.tgz文件，检查文件是否生成
            output = result.stdout.strip()
            self.assertTrue(output.endswith('.tgz'),
                          f"npm pack应该生成.tgz文件，实际输出: {output}")
    
            # 检查生成的文件是否存在
            tgz_file = self.project_root / output
            self.assertTrue(tgz_file.exists(),
                          f"生成的包文件{output}应该存在")
    
            # 清理生成的文件
            if tgz_file.exists():
                tgz_file.unlink()
    
        except subprocess.TimeoutExpired:
            self.fail("npm pack命令超时")
        except Exception as e:
>           self.fail(f"npm pack测试失败: {e}")
E           AssertionError: npm pack测试失败: 254 != 0 : npm pack失败: npm error code ENOENT
E           npm error syscall open
E           npm error path /Users/xuyehua/Code/remote-terminal-mcp/python/package.json
E           npm error errno -2
E           npm error enoent Could not read package.json: Error: ENOENT: no such file or directory, open '/Users/xuyehua/Code/remote-terminal-mcp/python/package.json'
E           npm error enoent This is related to npm not being able to find a file.
E           npm error enoent
E           npm error A complete log of this run can be found in: /Users/xuyehua/.npm/_logs/2025-07-16T16_05_14_995Z-debug-0.log

python/tests/tool_connect_server/test_package_integrity.py:137: AssertionError
______________ TestNPMPackagePublishing.test_version_consistency _______________

self = <python.tests.tool_connect_server.test_package_integrity.TestNPMPackagePublishing testMethod=test_version_consistency>

    def test_version_consistency(self):
        """测试版本一致性"""
        # 读取package.json版本
>       with open(self.project_root / 'package.json') as f:
E       FileNotFoundError: [Errno 2] No such file or directory: '/Users/xuyehua/Code/remote-terminal-mcp/python/package.json'

python/tests/tool_connect_server/test_package_integrity.py:177: FileNotFoundError
________ TestConfigurationRegression.test_config_directory_consistency _________

self = <python.tests.tool_connect_server.test_regression_prevention.TestConfigurationRegression testMethod=test_config_directory_consistency>

    def test_config_directory_consistency(self):
        """测试配置目录的一致性 - 防止目录名称变更"""
        from config_manager.main import EnhancedConfigManager
        from docker_config_manager import DockerConfigManager
    
        # 测试EnhancedConfigManager
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_regression_prevention.py:29: UnboundLocalError
____________ TestConfigurationRegression.test_config_file_structure ____________

self = <python.tests.tool_connect_server.test_regression_prevention.TestConfigurationRegression testMethod=test_config_file_structure>

    def test_config_file_structure(self):
        """测试配置文件结构的完整性"""
        from config_manager.main import EnhancedConfigManager
    
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_regression_prevention.py:51: UnboundLocalError
_________ TestMCPToolsRegression.test_interactive_wizard_functionality _________

self = <python.tests.tool_connect_server.test_regression_prevention.TestMCPToolsRegression testMethod=test_interactive_wizard_functionality>

    def test_interactive_wizard_functionality(self):
        """测试交互式向导功能是否正常"""
        from python.mcp_server import EnhancedConfigManager
    
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_regression_prevention.py:72: UnboundLocalError
_________ TestDockerConfigRegression.test_docker_command_completeness __________

self = <python.tests.tool_connect_server.test_regression_prevention.TestDockerConfigRegression testMethod=test_docker_command_completeness>

    def test_docker_command_completeness(self):
        """测试Docker命令生成的完整性"""
        from config_manager.main import EnhancedConfigManager
    
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_regression_prevention.py:109: UnboundLocalError
_ TestConfigurationPersistenceRegression.test_ensure_config_exists_preserves_user_config _

self = <python.tests.tool_connect_server.test_regression_prevention.TestConfigurationPersistenceRegression testMethod=test_ensure_config_exists_preserves_user_config>

        def test_ensure_config_exists_preserves_user_config(self):
            """测试ensure_config_exists不会覆盖用户配置"""
            # 设置测试环境
            os.environ['HOME'] = str(self.test_dir)
            self.config_dir.mkdir(parents=True, exist_ok=True)
    
            # 创建用户配置
            user_config = """# User Configuration
    global_settings:
      auto_recovery: true
      default_shell: zsh
      default_timeout: 90
      log_level: DEBUG
      default_server: "production"
    
    servers:
      example-server:
        description: "我的开发服务器"
        host: dev.mycompany.com
        port: 2222
        username: developer
        type: script_based
    
      production:
        description: "生产服务器"
        host: prod.mycompany.com
        port: 22
        username: admin
        type: script_based
    """
    
            with open(self.config_file, "w") as f:
                f.write(user_config)
    
            # 记录原始状态
            original_mtime = self.config_file.stat().st_mtime
            original_content = self.config_file.read_text()
    
            # 多次调用ensure_config_exists
            from config_manager.main import EnhancedConfigManager
>           manager = config_manager.main.EnhancedConfigManager()
E           NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_regression_prevention.py:227: NameError
_ TestConfigurationPersistenceRegression.test_get_existing_servers_preserves_user_modifications _

self = <python.tests.tool_connect_server.test_regression_prevention.TestConfigurationPersistenceRegression testMethod=test_get_existing_servers_preserves_user_modifications>

        def test_get_existing_servers_preserves_user_modifications(self):
            """测试get_existing_servers保留用户修改"""
            # 设置测试环境
            os.environ['HOME'] = str(self.test_dir)
            self.config_dir.mkdir(parents=True, exist_ok=True)
    
            # 创建包含用户修改的配置
            user_config = """servers:
      example-server:
        description: "我的测试服务器"
        host: test.example.com
        port: 2222
        username: testuser
        type: script_based
      custom-server:
        description: "自定义服务器"
        host: custom.example.com
        port: 22
        username: admin
        type: script_based
    """
    
            with open(self.config_file, "w") as f:
                f.write(user_config)
    
            # 多次调用get_existing_servers
            from config_manager.main import EnhancedConfigManager
>           manager = config_manager.main.EnhancedConfigManager()
E           NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_regression_prevention.py:268: NameError
_ TestConfigurationPersistenceRegression.test_modified_example_server_detection _

self = <python.tests.tool_connect_server.test_regression_prevention.TestConfigurationPersistenceRegression testMethod=test_modified_example_server_detection>

        def test_modified_example_server_detection(self):
            """测试修改过的示例服务器能被正确识别为用户配置"""
            # 设置测试环境
            os.environ['HOME'] = str(self.test_dir)
            self.config_dir.mkdir(parents=True, exist_ok=True)
    
            # 创建修改过的示例服务器配置
            modified_config = """servers:
      example-server:
        description: "我的开发服务器"
        host: dev.mycompany.com
        port: 2222
        username: developer
        type: script_based
    """
    
            with open(self.config_file, "w") as f:
                f.write(modified_config)
    
            # 在简化版本中，我们专注于配置文件的稳定性
            # 而不是智能检测，所以这个测试需要适应新的设计理念
            from config_manager.main import EnhancedConfigManager
>           manager = config_manager.main.EnhancedConfigManager()
E           NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_regression_prevention.py:172: NameError
___ TestConfigurationPersistenceRegression.test_npm_installation_protection ____

self = <python.tests.tool_connect_server.test_regression_prevention.TestConfigurationPersistenceRegression testMethod=test_npm_installation_protection>

        def test_npm_installation_protection(self):
            """测试NPM安装后的配置保护机制"""
            # 设置测试环境
            os.environ['HOME'] = str(self.test_dir)
            self.config_dir.mkdir(parents=True, exist_ok=True)
    
            # 创建NPM标记文件（模拟新安装）
            npm_marker = self.config_dir / ".npm_install_marker"
            npm_marker.touch()
    
            # 创建基本配置
            basic_config = """servers:
      example-server:
        description: "示例服务器配置"
        host: example.com
        port: 22
        username: your-username
        type: script_based
    """
    
            with open(self.config_file, "w") as f:
                f.write(basic_config)
    
            # 在简化版本中，我们专注于配置稳定性而不是复杂的NPM检测
            from config_manager.main import EnhancedConfigManager
>           manager = config_manager.main.EnhancedConfigManager()
E           NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_regression_prevention.py:310: NameError
____________ TestUserExperienceRegression.test_configuration_backup ____________

self = <python.tests.tool_connect_server.test_regression_prevention.TestUserExperienceRegression testMethod=test_configuration_backup>

    def test_configuration_backup(self):
        """测试配置备份功能"""
        from config_manager.main import EnhancedConfigManager
    
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_regression_prevention.py:341: UnboundLocalError
___________ TestUserExperienceRegression.test_error_messages_quality ___________

self = <python.tests.tool_connect_server.test_regression_prevention.TestUserExperienceRegression testMethod=test_error_messages_quality>

    def test_error_messages_quality(self):
        """测试错误消息的质量"""
        from config_manager.main import EnhancedConfigManager
    
        # 测试配置管理器在异常情况下的行为
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_regression_prevention.py:331: UnboundLocalError
______________ TestAPIConsistency.test_docker_config_manager_api _______________

self = <python.tests.tool_connect_server.test_regression_prevention.TestAPIConsistency testMethod=test_docker_config_manager_api>

    def test_docker_config_manager_api(self):
        """测试DockerConfigManager的API稳定性"""
        from docker_config_manager import DockerConfigManager
        from config_manager.main import EnhancedConfigManager
    
        docker_manager = DockerConfigManager()
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_regression_prevention.py:377: UnboundLocalError
_____________ TestAPIConsistency.test_enhanced_config_manager_api ______________

self = <python.tests.tool_connect_server.test_regression_prevention.TestAPIConsistency testMethod=test_enhanced_config_manager_api>

    def test_enhanced_config_manager_api(self):
        """测试EnhancedConfigManager的API稳定性"""
        from config_manager.main import EnhancedConfigManager
    
>       config_manager = config_manager.main.EnhancedConfigManager()
E       UnboundLocalError: local variable 'config_manager' referenced before assignment

python/tests/tool_connect_server/test_regression_prevention.py:354: UnboundLocalError
__________ TestSimpleAutomationDemo.test_mcp_guided_setup_automation ___________

self = <python.tests.tool_connect_server.test_simple_automated_demo.TestSimpleAutomationDemo testMethod=test_mcp_guided_setup_automation>

    def test_mcp_guided_setup_automation(self):
        """测试MCP引导配置自动化（无需交互）"""
        print("\n🎯 演示3: MCP引导配置自动化")
    
        # MCP模式的配置是参数化的，不需要用户输入
>       result = self.config_manager.mcp_guided_setup(
            server_name='demo-server',
            host='192.168.1.102',
            username='demouser',
            port=22,
            connection_type='ssh',
            description='自动化演示服务器'
        )
E       AttributeError: 'EnhancedConfigManager' object has no attribute 'mcp_guided_setup'

python/tests/tool_connect_server/test_simple_automated_demo.py:88: AttributeError
----------------------------- Captured stdout call -----------------------------

🎯 演示3: MCP引导配置自动化
___________ TestSimpleAutomationDemo.test_multiple_validation_types ____________

self = <python.tests.tool_connect_server.test_simple_automated_demo.TestSimpleAutomationDemo testMethod=test_multiple_validation_types>

    def test_multiple_validation_types(self):
        """测试多种验证类型的自动化"""
        print("\n🎯 演示4: 多种验证类型自动化")
    
        # 测试主机名验证
        with patch('builtins.input', return_value='test-host.com'):
            hostname = self.config_manager.smart_input(
                "主机名", validator=self.config_manager.validate_hostname
            )
        print(f"✅ 主机名验证: {hostname}")
    
        # 测试端口验证
        with patch('builtins.input', return_value='22'):
            port = self.config_manager.smart_input(
                "端口", validator=self.config_manager.validate_port
            )
        print(f"✅ 端口验证: {port}")
    
        # 测试用户名验证
        with patch('builtins.input', return_value='testuser'):
            username = self.config_manager.smart_input(
                "用户名", validator=self.config_manager.validate_username
            )
        print(f"✅ 用户名验证: {username}")
    
>       self.assertEqual(hostname, 'test-host.com')
E       AssertionError: None != 'test-host.com'

python/tests/tool_connect_server/test_simple_automated_demo.py:136: AssertionError
----------------------------- Captured stdout call -----------------------------

🎯 演示4: 多种验证类型自动化
输入验证失败：服务器地址不能包含空格。正确格式示例：192.168.1.100
✅ 主机名验证: None
输入验证失败：服务器地址不能包含空格。正确格式示例：192.168.1.100
✅ 端口验证: None
输入验证失败：服务器地址不能包含空格。正确格式示例：192.168.1.100
✅ 用户名验证: None
__________ TestSimpleAutomationDemo.test_smart_input_basic_automation __________

self = <python.tests.tool_connect_server.test_simple_automated_demo.TestSimpleAutomationDemo testMethod=test_smart_input_basic_automation>

    def test_smart_input_basic_automation(self):
        """测试smart_input基本自动化"""
        print("\n🎯 演示1: 基本smart_input自动化")
    
        # 模拟用户输入
        user_inputs = ['192.168.1.100']
    
        with patch('builtins.input', side_effect=user_inputs):
            with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                result = self.config_manager.smart_input(
                    "🌐 服务器地址",
                    validator=self.config_manager.validate_hostname
                )
                output = mock_stdout.getvalue()
    
        print(f"✅ 输入结果: {result}")
        print(f"📝 输出内容: {output.strip()}")
    
>       self.assertEqual(result, '192.168.1.100')
E       AssertionError: None != '192.168.1.100'

python/tests/tool_connect_server/test_simple_automated_demo.py:55: AssertionError
----------------------------- Captured stdout call -----------------------------

🎯 演示1: 基本smart_input自动化
✅ 输入结果: None
📝 输出内容: 输入验证失败：服务器地址不能包含空格。正确格式示例：192.168.1.100
_____ TestSimpleAutomationDemo.test_smart_input_error_recovery_automation ______

self = <python.tests.tool_connect_server.test_simple_automated_demo.TestSimpleAutomationDemo testMethod=test_smart_input_error_recovery_automation>

    def test_smart_input_error_recovery_automation(self):
        """测试smart_input错误恢复自动化"""
        print("\n🎯 演示2: 错误恢复自动化")
    
        # 模拟用户先输入错误，然后输入正确的值
        user_inputs = [
            'invalid host with spaces',  # 第一次输入错误
            '192.168.1.101'             # 第二次输入正确
        ]
    
        with patch('builtins.input', side_effect=user_inputs):
            with patch('sys.stdout', new_callable=StringIO) as mock_stdout:
                result = self.config_manager.smart_input(
                    "🌐 服务器地址",
                    validator=self.config_manager.validate_hostname
                )
                output = mock_stdout.getvalue()
    
        print(f"✅ 最终结果: {result}")
        print(f"📝 错误提示出现: {'输入验证失败' in output}")
        print(f"📝 详细提示出现: {'服务器地址不能包含空格' in output}")
    
>       self.assertEqual(result, '192.168.1.101')
E       AssertionError: None != '192.168.1.101'

python/tests/tool_connect_server/test_simple_automated_demo.py:79: AssertionError
----------------------------- Captured stdout call -----------------------------

🎯 演示2: 错误恢复自动化
✅ 最终结果: None
📝 错误提示出现: True
📝 详细提示出现: True
______________ TestZeroInteractionDemo.test_batch_server_creation ______________

self = <python.tests.tool_connect_server.test_zero_interaction_demo.TestZeroInteractionDemo testMethod=test_batch_server_creation>

    def setUp(self):
        """测试前准备"""
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_zero_interaction_demo.py:28: NameError
__________ TestZeroInteractionDemo.test_completely_headless_operation __________

self = <python.tests.tool_connect_server.test_zero_interaction_demo.TestZeroInteractionDemo testMethod=test_completely_headless_operation>

    def setUp(self):
        """测试前准备"""
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_zero_interaction_demo.py:28: NameError
___________ TestZeroInteractionDemo.test_completely_silent_mcp_setup ___________

self = <python.tests.tool_connect_server.test_zero_interaction_demo.TestZeroInteractionDemo testMethod=test_completely_silent_mcp_setup>

    def setUp(self):
        """测试前准备"""
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_zero_interaction_demo.py:28: NameError
________ TestZeroInteractionDemo.test_mock_all_interactions_completely _________

self = <python.tests.tool_connect_server.test_zero_interaction_demo.TestZeroInteractionDemo testMethod=test_mock_all_interactions_completely>

    def setUp(self):
        """测试前准备"""
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_zero_interaction_demo.py:28: NameError
____________ TestZeroInteractionDemo.test_smart_input_with_defaults ____________

self = <python.tests.tool_connect_server.test_zero_interaction_demo.TestZeroInteractionDemo testMethod=test_smart_input_with_defaults>

    def setUp(self):
        """测试前准备"""
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_zero_interaction_demo.py:28: NameError
___________ TestZeroInteractionDemo.test_validation_with_auto_retry ____________

self = <python.tests.tool_connect_server.test_zero_interaction_demo.TestZeroInteractionDemo testMethod=test_validation_with_auto_retry>

    def setUp(self):
        """测试前准备"""
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

python/tests/tool_connect_server/test_zero_interaction_demo.py:28: NameError
=========================== short test summary info ============================
FAILED python/tests/tool_connect_server/test_end_to_end.py::TestEndToEndWorkflow::test_complete_server_setup_workflow
FAILED python/tests/tool_connect_server/test_end_to_end.py::TestEndToEndWorkflow::test_mcp_integration_workflow
FAILED python/tests/tool_connect_server/test_end_to_end.py::TestUserScenarios::test_configuration_migration_scenario
FAILED python/tests/tool_connect_server/test_end_to_end.py::TestUserScenarios::test_new_user_setup_scenario
FAILED python/tests/tool_connect_server/test_fix_interactive_startup_requirement_20241222.py::TestInteractiveStartupRequirement::test_create_server_config_must_start_interactive_interface
FAILED python/tests/tool_connect_server/test_fix_interactive_startup_requirement_20241222.py::TestInteractiveStartupRequirement::test_interactive_startup_failure_diagnosis
FAILED python/tests/tool_connect_server/test_fix_interactive_startup_requirement_20241222.py::TestInteractiveStartupRequirement::test_interactive_startup_with_minimal_params
FAILED python/tests/tool_connect_server/test_fix_user_visible_interaction_20241222.py::TestUserVisibleInteraction::test_interactive_interface_accessibility
FAILED python/tests/tool_connect_server/test_fix_user_visible_interaction_20241222.py::TestUserVisibleInteraction::test_terminal_window_creation_on_macos
FAILED python/tests/tool_connect_server/test_fully_automated_interactive.py::TestFullyAutomatedInteractive::test_guided_setup_docker_server_full_automation
FAILED python/tests/tool_connect_server/test_fully_automated_interactive.py::TestFullyAutomatedInteractive::test_guided_setup_relay_server_full_automation
FAILED python/tests/tool_connect_server/test_fully_automated_interactive.py::TestFullyAutomatedInteractive::test_guided_setup_ssh_server_full_automation
FAILED python/tests/tool_connect_server/test_fully_automated_interactive.py::TestFullyAutomatedInteractive::test_smart_input_error_recovery_automation
FAILED python/tests/tool_connect_server/test_fully_automated_interactive.py::TestInputValidationAutomation::test_hostname_validation_automation
FAILED python/tests/tool_connect_server/test_fully_automated_interactive.py::TestInputValidationAutomation::test_port_validation_automation
FAILED python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_config_file_operations
FAILED python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_config_manager_tools
FAILED python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_docker_command_generation
FAILED python/tests/tool_connect_server/test_mcp_tools.py::TestMCPTools::test_server_config_creation
FAILED python/tests/tool_connect_server/test_mcp_tools.py::TestConfigurationConsistency::test_config_directory_consistency
FAILED python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_dependencies_installable
FAILED python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_main_entry_file
FAILED python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_package_json_exists
FAILED python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_package_json_structure
FAILED python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_required_python_files
FAILED python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageIntegrity::test_scripts_configuration
FAILED python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackageInstallation::test_npm_pack_success
FAILED python/tests/tool_connect_server/test_package_integrity.py::TestNPMPackagePublishing::test_version_consistency
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationRegression::test_config_directory_consistency
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationRegression::test_config_file_structure
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestMCPToolsRegression::test_interactive_wizard_functionality
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestDockerConfigRegression::test_docker_command_completeness
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationPersistenceRegression::test_ensure_config_exists_preserves_user_config
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationPersistenceRegression::test_get_existing_servers_preserves_user_modifications
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationPersistenceRegression::test_modified_example_server_detection
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestConfigurationPersistenceRegression::test_npm_installation_protection
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestUserExperienceRegression::test_configuration_backup
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestUserExperienceRegression::test_error_messages_quality
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestAPIConsistency::test_docker_config_manager_api
FAILED python/tests/tool_connect_server/test_regression_prevention.py::TestAPIConsistency::test_enhanced_config_manager_api
FAILED python/tests/tool_connect_server/test_simple_automated_demo.py::TestSimpleAutomationDemo::test_mcp_guided_setup_automation
FAILED python/tests/tool_connect_server/test_simple_automated_demo.py::TestSimpleAutomationDemo::test_multiple_validation_types
FAILED python/tests/tool_connect_server/test_simple_automated_demo.py::TestSimpleAutomationDemo::test_smart_input_basic_automation
FAILED python/tests/tool_connect_server/test_simple_automated_demo.py::TestSimpleAutomationDemo::test_smart_input_error_recovery_automation
FAILED python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_batch_server_creation
FAILED python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_completely_headless_operation
FAILED python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_completely_silent_mcp_setup
FAILED python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_mock_all_interactions_completely
FAILED python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_smart_input_with_defaults
FAILED python/tests/tool_connect_server/test_zero_interaction_demo.py::TestZeroInteractionDemo::test_validation_with_auto_retry
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 50 failures !!!!!!!!!!!!!!!!!!!!!!!!!!
================= 50 failed, 67 passed, 22 warnings in 15.40s ==================
