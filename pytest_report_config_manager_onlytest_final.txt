============================= test session starts ==============================
platform darwin -- Python 3.9.6, pytest-8.3.5, pluggy-1.5.0
rootdir: /Users/xuyehua/Code/remote-terminal-mcp
plugins: anyio-4.9.0, cov-6.1.1, asyncio-1.0.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 85 items

tests/tool_add_server_config/test_docker_config.py .                     [  1%]
tests/tool_add_server_config/test_fix_config_auto_creation_removal_20241222.py . [  2%]
......                                                                   [  9%]
tests/tool_add_server_config/test_fix_save_config_parameter_mismatch_20250615.py F [ 10%]
FFF                                                                      [ 14%]
tests/tool_add_server_config/test_interaction.py ...                     [ 17%]
tests/tool_add_server_config/test_interactive_create_server_config.py F  [ 18%]
tests/tool_add_server_config/test_interactive_create_server_config_prefill.py F [ 20%]
                                                                         [ 20%]
tests/tool_add_server_config/test_io.py .                                [ 21%]
tests/tool_delete_server_config/test_fix_config_ux_and_prefill_bug.py FF [ 23%]
                                                                         [ 23%]
tests/tool_disconnect_server/test_fix_terminal_cleanup_bug_20241222.py . [ 24%]
.......                                                                  [ 32%]
tests/tool_execute_command/test_fix_example_mcp_testing_20240622.py F..F [ 37%]
....                                                                     [ 42%]
tests/tool_execute_command/test_fix_mcp_restart_and_new_code_loading_20241222.py . [ 43%]
.....F.                                                                  [ 51%]
tests/tool_get_server_info/test_server_info.py ...                       [ 55%]
tests/tool_get_server_status/test_fix_quality_assurance_rules_20240622.py . [ 56%]
.F.F.                                                                    [ 62%]
tests/tool_list_servers/test_mcp_silent_config_regression.py FFFFFss     [ 70%]
tests/tool_sync_config/test_auto_sync_manager_implementation.py ........ [ 80%]
                                                                         [ 80%]
tests/tool_sync_config/test_sync_config.py .                             [ 81%]
tests/tool_sync_config/test_sync_config_ui_enhancement.py FFFFFFFF       [ 90%]
tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py F [ 91%]
FFFFF                                                                    [ 97%]
tests/tool_update_server_config/test_interactive_update_server_config.py F [ 98%]
                                                                         [ 98%]
tests/tool_update_server_config/test_interactive_update_server_config_prefill.py F [100%]

=================================== FAILURES ===================================
_____ TestSaveConfigParameterFix.test_regression_server_deletion_scenario ______

self = <test_fix_save_config_parameter_mismatch_20250615.TestSaveConfigParameterFix testMethod=test_regression_server_deletion_scenario>

    def test_regression_server_deletion_scenario(self):
        """æµ‹è¯•æœåŠ¡å™¨åˆ é™¤åœºæ™¯çš„å›å½’æµ‹è¯•"""
        # åˆ›å»ºæµ‹è¯•é…ç½®
        initial_config = {
            'servers': {
                'test_server1': {
                    'host': 'test1.example.com',
                    'username': 'user1',
                    'port': 22
                },
                'test_server2': {
                    'host': 'test2.example.com',
                    'username': 'user2',
                    'port': 22
                }
            }
        }
    
        # ä¿å­˜åˆå§‹é…ç½®
>       self.config_manager.io.save_config(initial_config, merge=False)
E       AttributeError: 'EnhancedConfigManager' object has no attribute 'io'

tests/tool_add_server_config/test_fix_save_config_parameter_mismatch_20250615.py:130: AttributeError
____ TestSaveConfigParameterFix.test_save_config_parameter_name_consistency ____

self = <test_fix_save_config_parameter_mismatch_20250615.TestSaveConfigParameterFix testMethod=test_save_config_parameter_name_consistency>

    def test_save_config_parameter_name_consistency(self):
        """æµ‹è¯• save_config æ–¹æ³•å‚æ•°åä¸€è‡´æ€§"""
        import inspect
    
        # è·å– save_config æ–¹æ³•çš„ç­¾å
>       sig = inspect.signature(self.config_manager.io.save_config)
E       AttributeError: 'EnhancedConfigManager' object has no attribute 'io'

tests/tool_add_server_config/test_fix_save_config_parameter_mismatch_20250615.py:103: AttributeError
_________ TestSaveConfigParameterFix.test_save_config_with_merge_false _________

self = <test_fix_save_config_parameter_mismatch_20250615.TestSaveConfigParameterFix testMethod=test_save_config_with_merge_false>

    def test_save_config_with_merge_false(self):
        """æµ‹è¯• save_config æ–¹æ³•ä½¿ç”¨ merge=False å‚æ•°"""
        test_config = {
            'servers': {
                'test_server': {
                    'host': 'test.example.com',
                    'username': 'testuser',
                    'port': 22,
                    'description': 'Test server'
                }
            }
        }
    
        # è¿™åº”è¯¥æˆåŠŸå·¥ä½œï¼Œä¸æŠ›å‡ºå‚æ•°é”™è¯¯
        try:
>           self.config_manager.io.save_config(test_config, merge=False)
E           AttributeError: 'EnhancedConfigManager' object has no attribute 'io'

tests/tool_add_server_config/test_fix_save_config_parameter_mismatch_20250615.py:87: AttributeError
_______ TestSaveConfigParameterFix.test_save_config_with_merge_parameter _______

self = <test_fix_save_config_parameter_mismatch_20250615.TestSaveConfigParameterFix testMethod=test_save_config_with_merge_parameter>

    def test_save_config_with_merge_parameter(self):
        """æµ‹è¯• save_config æ–¹æ³•ä½¿ç”¨æ­£ç¡®çš„ merge å‚æ•°"""
        test_config = {
            'servers': {
                'test_server': {
                    'host': 'test.example.com',
                    'username': 'testuser',
                    'port': 22,
                    'description': 'Test server'
                }
            }
        }
    
        # è¿™åº”è¯¥æˆåŠŸå·¥ä½œï¼Œä¸æŠ›å‡ºå‚æ•°é”™è¯¯
        try:
>           self.config_manager.io.save_config(test_config, merge=True)
E           AttributeError: 'EnhancedConfigManager' object has no attribute 'io'

tests/tool_add_server_config/test_fix_save_config_parameter_mismatch_20250615.py:54: AttributeError
____________________ test_interactive_create_server_config _____________________

    def test_interactive_create_server_config():
        # æµ‹è¯•å‰æ¸…ç†
        if os.path.exists(TEST_CONFIG_PATH):
            os.remove(TEST_CONFIG_PATH)
        # patch input å®ç°è‡ªåŠ¨åŒ–äº¤äº’
        with patch("builtins.input", side_effect=MOCK_INPUTS):
>           manager = EnhancedConfigManager(config_path=TEST_CONFIG_PATH, force_interactive=True)
E           TypeError: __init__() got an unexpected keyword argument 'force_interactive'

tests/tool_add_server_config/test_interactive_create_server_config.py:43: TypeError
________________ test_interactive_create_server_config_prefill _________________

    def test_interactive_create_server_config_prefill():
        # æµ‹è¯•å‰æ¸…ç†
        if os.path.exists(TEST_CONFIG_PATH):
            os.remove(TEST_CONFIG_PATH)
        # é¢„å¡«å‚æ•°
        prefill = {
            'name': 'hg225',
            'host': '192.168.1.225',
            'username': 'admin',
        }
        with patch("builtins.input", side_effect=MOCK_INPUTS):
>           manager = EnhancedConfigManager(config_path=TEST_CONFIG_PATH, force_interactive=True)
E           TypeError: __init__() got an unexpected keyword argument 'force_interactive'

tests/tool_add_server_config/test_interactive_create_server_config_prefill.py:45: TypeError
__________ TestConfigUXPrefillFix.test_guided_setup_for_relay_server ___________

self = <test_fix_config_ux_and_prefill_bug.TestConfigUXPrefillFix testMethod=test_guided_setup_for_relay_server>

    def test_guided_setup_for_relay_server(self):
        """
        æ–°å¢æµ‹è¯•ï¼šé€šè¿‡å‘å¯¼æ¨¡å¼æ›´æ–°äºŒçº§è·³æ¿æœåŠ¡å™¨ï¼Œç¡®ä¿è°ƒç”¨_configure_serveræ—¶ä¸å†å‡ºé”™ã€‚
        """
        # æ¨¡æ‹Ÿç”¨æˆ·é€šè¿‡ guided_setup æ›´æ–° hg222
        inputs = [
            '1', # 1. Relayè·³æ¿æœºè¿æ¥
            'hg222-guided', # æœåŠ¡å™¨åç§°
            '2', # 2. äºŒçº§è·³æ¿
            # 3. é…ç½®ç¬¬ä¸€çº§è·³æ¿æœº
            "relay@relay-host.com",
            "22",
            "relay_pass",
            # 4. é…ç½®æœ€ç»ˆç›®æ ‡æœåŠ¡å™¨
            "target@target-host.com",
            "2222",
            "target_pass",
            # 5. ä¸é…ç½®Docker
            "n",
            # 6. ç¡®è®¤ä¿å­˜
            "y"
        ]
    
        # ä½¿ç”¨è‡ªåŠ¨åŒ–äº¤äº’æµ‹è¯•å·¥å…·æ¥è¿è¡Œ
        # æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ä¸ç›´æ¥è°ƒç”¨ --editï¼Œè€Œæ˜¯æ¨¡æ‹Ÿä»ä¸»èœå•è¿›å…¥å‘å¯¼
>       tester = AutomatedInteractionTester(
            target_script='enhanced_config_manager.py',
            inputs=inputs,
            script_args=['--config', str(self.config_path), '--mode', 'guided']
        )
E       TypeError: __init__() got an unexpected keyword argument 'target_script'

tests/tool_delete_server_config/test_fix_config_ux_and_prefill_bug.py:146: TypeError
_____ TestConfigUXPrefillFix.test_update_relay_server_with_prefill_issues ______

self = <test_fix_config_ux_and_prefill_bug.TestConfigUXPrefillFix testMethod=test_update_relay_server_with_prefill_issues>

    def test_update_relay_server_with_prefill_issues(self):
        """
        æµ‹è¯•æ›´æ–°äºŒçº§è·³æ¿æœåŠ¡å™¨çš„æµç¨‹ï¼Œç¡®ä¿ï¼š
        1. UXæ˜¯ç®€æ´çš„ user@host -> password æ¨¡å¼ã€‚
        2. é¢„å¡«å……ä¸å®Œæ•´çš„å‚æ•°ä¸ä¼šå¯¼è‡´å´©æºƒã€‚
        """
        # æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥åºåˆ—
        inputs = [
            "hg222",  # 1. é€‰æ‹©è¦ç¼–è¾‘çš„æœåŠ¡å™¨
            "y",      # 2. ç¡®è®¤ç¼–è¾‘
            # 3. é…ç½®ç¬¬ä¸€çº§è·³æ¿æœº (Relay Host)
            "user1@relay-host.com",
            "22",
            "relay_password_123",
            # 4. é…ç½®æœ€ç»ˆç›®æ ‡æœåŠ¡å™¨ (Jump Host)
            "user2@final-dest.com",
            "2222",
            "final_dest_password_456",
            "n" # 5.ä¸é…ç½®DOCKER
        ]
    
        # ä½¿ç”¨è‡ªåŠ¨åŒ–äº¤äº’æµ‹è¯•å·¥å…·æ¥è¿è¡Œ
>       tester = AutomatedInteractionTester(
            target_script='enhanced_config_manager.py',
            inputs=inputs,
            script_args=['--config', str(self.config_path), '--edit', 'hg222']
        )
E       TypeError: __init__() got an unexpected keyword argument 'target_script'

tests/tool_delete_server_config/test_fix_config_ux_and_prefill_bug.py:88: TypeError
____________ TestMCPToolingFramework.test_reproduce_original_issue _____________

self = <test_fix_example_mcp_testing_20240622.TestMCPToolingFramework object at 0x107c2f310>

    @pytest.mark.asyncio
    async def test_reproduce_original_issue(self):
        """
        å¤ç°åŸå§‹é—®é¢˜çš„æœ€å°æ¡ˆä¾‹
    
        å‡è®¾é—®é¢˜ï¼šMCPå·¥å…·è°ƒç”¨æ—¶æ— æ³•æ­£ç¡®å¤„ç†é”™è¯¯å“åº”
        """
        # è¿™é‡Œæ˜¯é—®é¢˜å¤ç°é€»è¾‘çš„ç¤ºä¾‹
        # åœ¨å®é™…ä½¿ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥åŒ…å«èƒ½å¤Ÿå¤ç°åŸå§‹é—®é¢˜çš„æœ€å°ä»£ç 
    
        client = create_mcp_test_client()
    
        # å°è¯•è°ƒç”¨ä¸å­˜åœ¨çš„å·¥å…·ï¼Œåº”è¯¥å¾—åˆ°æ˜ç¡®çš„é”™è¯¯ä¿¡æ¯
        with pytest.raises(MCPTestError) as exc_info:
            await client.call_tool("non_existent_tool")
    
        # éªŒè¯é”™è¯¯ä¿¡æ¯æ˜¯å¦åŒ…å«æœŸæœ›çš„å†…å®¹
>       assert "non_existent_tool" in str(exc_info.value) or "ä¸å­˜åœ¨" in str(exc_info.value)
E       assert ('non_existent_tool' in "MCPæœåŠ¡å™¨é”™è¯¯: /Applications/Xcode.app/Contents/Developer/usr/bin/python3: can't open file '/Users/xuyehua/Code/remote-terminal-mcp/python/python/mcp_server.py': [Errno 2] No such file or directory\n" or 'ä¸å­˜åœ¨' in "MCPæœåŠ¡å™¨é”™è¯¯: /Applications/Xcode.app/Contents/Developer/usr/bin/python3: can't open file '/Users/xuyehua/Code/remote-terminal-mcp/python/python/mcp_server.py': [Errno 2] No such file or directory\n")
E        +  where "MCPæœåŠ¡å™¨é”™è¯¯: /Applications/Xcode.app/Contents/Developer/usr/bin/python3: can't open file '/Users/xuyehua/Code/remote-terminal-mcp/python/python/mcp_server.py': [Errno 2] No such file or directory\n" = str(MCPTestError("MCPæœåŠ¡å™¨é”™è¯¯: /Applications/Xcode.app/Contents/Developer/usr/bin/python3: can't open file '/Users/xuyehua/Code/remote-terminal-mcp/python/python/mcp_server.py': [Errno 2] No such file or directory\n"))
E        +    where MCPTestError("MCPæœåŠ¡å™¨é”™è¯¯: /Applications/Xcode.app/Contents/Developer/usr/bin/python3: can't open file '/Users/xuyehua/Code/remote-terminal-mcp/python/python/mcp_server.py': [Errno 2] No such file or directory\n") = <ExceptionInfo MCPTestError("MCPæœåŠ¡å™¨é”™è¯¯: /Applications/Xcode.app/Contents/Developer/usr/bin/python3: can't open file '/Users/xuyehua/Code/remote-terminal-mcp/python/python/mcp_server.py': [Errno 2] No such file or directory\n") tblen=2>.value
E        +  and   "MCPæœåŠ¡å™¨é”™è¯¯: /Applications/Xcode.app/Contents/Developer/usr/bin/python3: can't open file '/Users/xuyehua/Code/remote-terminal-mcp/python/python/mcp_server.py': [Errno 2] No such file or directory\n" = str(MCPTestError("MCPæœåŠ¡å™¨é”™è¯¯: /Applications/Xcode.app/Contents/Developer/usr/bin/python3: can't open file '/Users/xuyehua/Code/remote-terminal-mcp/python/python/mcp_server.py': [Errno 2] No such file or directory\n"))
E        +    where MCPTestError("MCPæœåŠ¡å™¨é”™è¯¯: /Applications/Xcode.app/Contents/Developer/usr/bin/python3: can't open file '/Users/xuyehua/Code/remote-terminal-mcp/python/python/mcp_server.py': [Errno 2] No such file or directory\n") = <ExceptionInfo MCPTestError("MCPæœåŠ¡å™¨é”™è¯¯: /Applications/Xcode.app/Contents/Developer/usr/bin/python3: can't open file '/Users/xuyehua/Code/remote-terminal-mcp/python/python/mcp_server.py': [Errno 2] No such file or directory\n") tblen=2>.value

tests/tool_execute_command/test_fix_example_mcp_testing_20240622.py:50: AssertionError
________ TestMCPToolingFramework.test_integration_with_other_components ________

self = <test_fix_example_mcp_testing_20240622.TestMCPToolingFramework object at 0x107c2f490>

    @pytest.mark.asyncio
    async def test_integration_with_other_components(self):
        """
        ç¡®ä¿ä¿®å¤ä¸å½±å“å…¶ä»–åŠŸèƒ½
    
        æµ‹è¯•MCPå·¥å…·è°ƒç”¨ä¸å…¶ä»–ç»„ä»¶çš„é›†æˆ
        """
        async with create_test_environment() as test_env:
            client = create_mcp_test_client()
    
            # åˆ›å»ºæµ‹è¯•é…ç½®
            test_config = {
                "servers": {
                    "test-server": {
                        "type": "ssh",
                        "host": "localhost",
                        "user": "testuser",
                        "port": 22
                    }
                }
            }
    
            test_env.create_test_config("test-server", test_config)
    
            # æµ‹è¯•é…ç½®è¯»å–åŠŸèƒ½
            try:
                servers = await client.call_tool("list_servers", {}, timeout=3.0)
                # åº”è¯¥èƒ½å¤Ÿè¯»å–åˆ°é…ç½®ï¼ˆæˆ–ç»™å‡ºåˆç†çš„é”™è¯¯ä¿¡æ¯ï¼‰
                assert isinstance(servers, (list, str))
    
            except MCPTestError as e:
                # é”™è¯¯ä¿¡æ¯åº”è¯¥æœ‰æ„ä¹‰
                error_msg = str(e)
                assert len(error_msg) > 0
    
            # æµ‹è¯•æœåŠ¡å™¨ä¿¡æ¯è·å–
            try:
>               if isinstance(servers, list) and len(servers) > 0:
E               UnboundLocalError: local variable 'servers' referenced before assignment

tests/tool_execute_command/test_fix_example_mcp_testing_20240622.py:138: UnboundLocalError
_ TestMCPRestartAndNewCodeLoading.test_new_update_server_config_logic_loading __

self = <test_fix_mcp_restart_and_new_code_loading_20241222.TestMCPRestartAndNewCodeLoading testMethod=test_new_update_server_config_logic_loading>

    def test_new_update_server_config_logic_loading(self):
        """æµ‹è¯•æ–°çš„update_server_configé€»è¾‘æ˜¯å¦æ­£ç¡®åŠ è½½"""
        print("ğŸ¯ æµ‹è¯•æ–°çš„update_server_configé€»è¾‘åŠ è½½")
    
        # æ£€æŸ¥ä»£ç ä¸­æ˜¯å¦åŒ…å«æ–°çš„é€»è¾‘æ ‡è®°
        with open(self.mcp_server_path, 'r', encoding='utf-8') as f:
            content = f.read()
    
        # éªŒè¯æ–°é€»è¾‘æ ‡è®°å­˜åœ¨
>       self.assertIn("NEW UPDATE LOGIC", content,
            "ä»£ç ä¸­åº”è¯¥åŒ…å«æ–°çš„update_server_configé€»è¾‘æ ‡è®°")
E       AssertionError: 'NEW UPDATE LOGIC' not found in '#!/usr/bin/env python3\n"""\nRemote Terminal MCP Server\n\nMCP server focused on remote server connections, session management and command execution\n"""\n\nimport asyncio\nimport json\nimport sys\nimport os\nimport subprocess\nimport traceback\nfrom pathlib import Path\nfrom datetime import datetime\nimport yaml\n\n# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°è·¯å¾„ï¼Œä»¥ä¾¿å¯¼å…¥enhanced_config_manager\nproject_root = Path(__file__).parent.parent\nsys.path.insert(0, str(project_root))\n\n# æ›¿æ¢åŸæœ‰å¯¼å…¥\n#from config_manager.main import EnhancedConfigManager\nfrom python.config_manager.main import EnhancedConfigManager\n# ä¿®å¤å¯¼å…¥è·¯å¾„ - enhanced_ssh_manageråœ¨pythonç›®å½•ä¸‹\nsys.path.insert(0, str(Path(__file__).parent))\nfrom enhanced_ssh_manager import EnhancedSSHManager, log_output, create_enhanced_manager\n\n# å¯¼å…¥coloramaç”¨äºå½©è‰²è¾“å‡ºæ”¯æŒ\ntry:\n    from colorama import Fore, Style, init\n    init()  # åˆå§‹åŒ–colorama\nexcept ImportError:\n    # å¦‚æœcoloramaä¸å¯ç”¨ï¼Œåˆ›å»ºç©ºçš„æ›¿ä»£\n    class Fore:\n        CYAN = ""\n        GREEN = ""\n        RED = ""\n        YELLOW = ""\n        WHITE = ""\n    class Style:\n        RESET_ALL = ""\n\n# æœåŠ¡å™¨ä¿¡æ¯\nSERVER_NAME = "remote-terminal-mcp"\nSERVER_VERSION = "0.7.0-mcp-integrated-config"\n\n# è®¾ç½®å®‰é™æ¨¡å¼ï¼Œé˜²æ­¢SSH Manageræ˜¾ç¤ºå¯åŠ¨æ‘˜è¦\nos.environ[\'MCP_QUIET\'] = \'1\'\n\n# è°ƒè¯•æ¨¡å¼\nDEBUG = os.getenv(\'MCP_DEBUG\', \'0\') == \'1\'\n\ndef debug_log(msg):\n    """æ”¹è¿›çš„è°ƒè¯•æ—¥å¿—å‡½æ•°ï¼Œé¿å…stderrè¾“å‡ºè¢«è¯¯æ ‡è®°ä¸ºé”™è¯¯"""\n    if DEBUG:\n        # åªåœ¨æ˜ç¡®å¯ç”¨è°ƒè¯•æ¨¡å¼æ—¶æ‰è¾“å‡º\n        print(f"[DEBUG] {msg}", file=sys.stderr, flush=True)\n\ndef info_log(msg):\n    """ä¿¡æ¯çº§åˆ«æ—¥å¿—ï¼Œè¾“å‡ºåˆ°stderrä½†ä¸ä¼šè¢«è¯¯æ ‡è®°"""\n    # ä½¿ç”¨æ›´æ¸©å’Œçš„ä¿¡æ¯è¾“å‡ºï¼Œé¿å…åœ¨æ­£å¸¸è¿è¡Œæ—¶äº§ç”Ÿé”™è¯¯çº§åˆ«æ—¥å¿—\n    pass  # åœ¨MCPç¯å¢ƒä¸­ï¼Œæˆ‘ä»¬å°½é‡ä¿æŒé™é»˜\n\ndef create_success_response(request_id, text_content):\n    """åˆ›å»ºä¸€ä¸ªåŒ…å«æ–‡æœ¬å†…å®¹çš„æˆåŠŸJSON-RPCå“åº”"""\n    return {\n        "jsonrpc": "2.0",\n        "id": request_id,\n        "result": {\n            "contentType": "text/plain",\n            "content": text_content\n        }\n    }\n\ndef create_error_response(request_id, code, message):\n    """åˆ›å»ºä¸€ä¸ªæ ‡å‡†çš„JSON-RPCé”™è¯¯å“åº”"""\n    return {\n        "jsonrpc": "2.0",\n        "id": request_id,\n        "error": {\n            "code": code,\n            "message": message\n        }\n    }\n\ndef run_command(cmd, cwd=None, timeout=30):\n    """Execute commandå¹¶è¿”å›ç»“æœ"""\n    try:\n        debug_log(f"Running command: {cmd}")\n        result = subprocess.run(\n            cmd, \n            shell=True, \n            capture_output=True, \n            text=True, \n            timeout=timeout,\n            cwd=cwd\n        )\n        \n        output = ""\n        if result.stdout:\n            output += f"Output:\\n{result.stdout}\\n"\n        if result.stderr:\n            output += f"Error output:\\n{result.stderr}\\n"\n        \n        output += f"Exit code: {result.returncode}"\n        \n        return output, result.returncode == 0\n        \n    except subprocess.TimeoutExpired:\n        return f"Command execution timeout ({timeout}s)", False\n    except Exception as e:\n        return f"Command execution failed: {str(e)}", False\n\ndef create_tools_list():\n    """åˆ›å»ºå·¥å…·åˆ—è¡¨ï¼ŒåŸºäºSSH Managerçš„å®é™…åŠŸèƒ½"""\n    return [\n        {\n            "name": "list_servers",\n            "description": "List all available remote servers configured in the system",\n            "inputSchema": {\n                "type": "object",\n                "properties": {},\n                "required": []\n            }\n        },\n        {\n            "name": "connect_server", \n            "description": "Connect to a remote server by name",\n            "inputSchema": {\n                "type": "object",\n                "properties": {\n                    "server_name": {\n                        "type": "string",\n                        "description": "Name of the server to connect to"\n                    }\n                },\n                "required": ["server_name"]\n            }\n        },\n        {\n            "name": "disconnect_server",\n            "description": "Disconnect from a remote server and clean up resources",\n            "inputSchema": {\n                "type": "object",\n                "properties": {\n                    "server_name": {\n                        "type": "string",\n                        "description": "Name of the server to disconnect from"\n                    },\n                    "force": {\n                        "type": "boolean",\n                        "description": "Force disconnect even if there are active sessions (default: false)",\n                        "default": False\n                    }\n                },\n                "required": ["server_name"]\n            }\n        },\n        {\n            "name": "execute_command",\n            "description": "Execute a command on a server",\n            "inputSchema": {\n                "type": "object", \n                "properties": {\n                    "command": {\n                        "type": "string",\n                        "description": "Command to execute"\n                    },\n                    "server": {\n                        "type": "string",\n                        "description": "Server name (optional, uses default if not specified)"\n                    }\n                },\n                "required": ["command"]\n            }\n        },\n        {\n            "name": "get_server_status",\n            "description": "Get connection status of servers",\n            "inputSchema": {\n                "type": "object",\n                "properties": {\n                    "server_name": {\n                        "type": "string", \n                        "description": "Server name (optional, gets all if not specified)"\n                    }\n                },\n                "required": []\n            }\n        },\n        {\n            "name": "get_server_info",\n            "description": "Get detailed configuration information for a specific server",\n            "inputSchema": {\n                "type": "object",\n                "properties": {\n                    "server_name": {\n                        "type": "string",\n                        "description": "Name of the server to get detailed information for"\n                    }\n                },\n                "required": ["server_name"]\n            }\n        },\n        {\n            "name": "run_local_command",\n            "description": "Execute a command on the local system",\n            "inputSchema": {\n                "type": "object",\n                "properties": {\n                    "cmd": {\n                        "type": "string",\n                        "description": "Command to execute locally"\n                    },\n                    "cwd": {\n                        "type": "string",\n                        "description": "Working directory (optional)"\n                    },\n                    "timeout": {\n                        "type": "number",\n                        "description": "Timeout in seconds (default: 30)"\n                    }\n                },\n                "required": ["cmd"]\n            }\n        },\n        # é…ç½®ç®¡ç†å·¥å…· - interactive_config_wizardåŠŸèƒ½å·²å†…ç½®åˆ°create/updateå·¥å…·ä¸­\n        {\n            "name": "diagnose_connection",\n            "description": "Diagnose connection issues and provide troubleshooting suggestions for a specific server",\n            "inputSchema": {\n                "type": "object",\n                "properties": {\n                    "server_name": {\n                        "type": "string",\n                        "description": "Name of the server to diagnose"\n                    },\n                    "include_network_test": {\n                        "type": "boolean",\n                        "description": "Include network connectivity tests (ping, SSH)",\n                        "default": True\n                    },\n                    "include_config_validation": {\n                        "type": "boolean",\n                        "description": "Include configuration validation",\n                        "default": True\n                    }\n                },\n                "required": ["server_name"]\n            }\n        },\n        {\n            "name": "create_server_config",\n            "description": "ğŸš€ æ™ºèƒ½æœåŠ¡å™¨é…ç½®åˆ›å»ºå·¥å…· - æ”¯æŒå…³é”®è¯è¯†åˆ«å’Œå‚æ•°åŒ–é…ç½®ã€‚ğŸŒŸ æ–°ç­–ç•¥ï¼šå³ä½¿æä¾›äº†å‚æ•°ï¼Œä¹Ÿé»˜è®¤è¿›å…¥äº¤äº’ç•Œé¢ï¼ˆå‚æ•°ä½œä¸ºé¢„å¡«å……é»˜è®¤å€¼ï¼‰ï¼Œç¡®ä¿ç”¨æˆ·å¯¹é…ç½®æœ‰å®Œå…¨çš„æ§åˆ¶æƒå’Œå¯è§æ€§ã€‚ğŸ” æ™ºèƒ½åˆ‡æ¢ï¼šè‡ªåŠ¨æ£€æµ‹æœåŠ¡å™¨æ˜¯å¦å·²å­˜åœ¨ï¼Œå¦‚å­˜åœ¨åˆ™è‡ªåŠ¨åˆ‡æ¢åˆ°æ›´æ–°æ¨¡å¼ã€‚å¯ä»¥é€šè¿‡è‡ªç„¶è¯­è¨€æè¿°æˆ–ç›´æ¥æä¾›é…ç½®å‚æ•°æ¥åˆ›å»ºæœåŠ¡å™¨ã€‚",\n            "inputSchema": {\n                "type": "object",\n                "properties": {\n                    "prompt": {\n                        "type": "string",\n                        "description": "ç”¨æˆ·çš„é…ç½®éœ€æ±‚æè¿°ï¼Œæ”¯æŒè‡ªç„¶è¯­è¨€ã€‚ä¾‹å¦‚ï¼š\'åˆ›å»ºä¸€ä¸ªæ–°çš„æœåŠ¡å™¨é…ç½®\'ã€\'æˆ‘æƒ³æ·»åŠ ä¸€å°æœåŠ¡å™¨\'ç­‰"\n                    },\n                    "name": {\n                        "type": "string",\n                        "description": "æœåŠ¡å™¨åç§°ï¼ˆå”¯ä¸€æ ‡è¯†ç¬¦ï¼‰"\n                    },\n                    "host": {\n                        "type": "string",\n                        "description": "æœåŠ¡å™¨ä¸»æœºåæˆ–IPåœ°å€"\n                    },\n                    "username": {\n                        "type": "string",\n                        "description": "SSHè¿æ¥ç”¨æˆ·å"\n                    },\n                    "port": {\n                        "type": "integer",\n                        "description": "SSHç«¯å£å·",\n                        "default": 22\n                    },\n                    "connection_type": {\n                        "type": "string",\n                        "description": "è¿æ¥ç±»å‹ï¼šsshï¼ˆç›´è¿ï¼‰æˆ–relayï¼ˆé€šè¿‡relay-cliï¼‰",\n                        "enum": ["ssh", "relay"],\n                        "default": "ssh"\n                    },\n                    "description": {\n                        "type": "string",\n                        "description": "æœåŠ¡å™¨æè¿°ä¿¡æ¯"\n                    },\n                    "relay_target_host": {\n                        "type": "string",\n                        "description": "å½“ä½¿ç”¨relayè¿æ¥æ—¶çš„ç›®æ ‡ä¸»æœº"\n                    },\n                    "docker_enabled": {\n                        "type": "boolean",\n                        "description": "æ˜¯å¦å¯ç”¨Dockerå®¹å™¨æ”¯æŒ",\n                        "default": False\n                    },\n                    "docker_image": {\n                        "type": "string",\n                        "description": "Dockeré•œåƒåç§°ï¼ˆå½“docker_enabled=trueæ—¶ä½¿ç”¨ï¼‰",\n                        "default": "ubuntu:20.04"\n                    },\n                    "docker_container": {\n                        "type": "string",\n                        "description": "Dockerå®¹å™¨åç§°ï¼ˆå½“docker_enabled=trueæ—¶ä½¿ç”¨ï¼‰"\n                    },\n                    "docker_ports": {\n                        "type": "array",\n                        "items": {"type": "string"},\n                        "description": "Dockerç«¯å£æ˜ å°„åˆ—è¡¨ï¼Œæ ¼å¼ï¼š[\\"host:container\\"]ï¼Œä¾‹å¦‚ï¼š[\\"8080:8080\\", \\"5000:5000\\"]",\n                        "default": ["8080:8080", "8888:8888", "6006:6006"]\n                    },\n                    "docker_volumes": {\n                        "type": "array",\n                        "items": {"type": "string"},\n                        "description": "Dockerå·æŒ‚è½½åˆ—è¡¨ï¼Œæ ¼å¼ï¼š[\\"host:container\\"]ï¼Œä¾‹å¦‚ï¼š[\\"/home:/home\\", \\"/data:/data\\"]",\n                        "default": ["/home:/home", "/data:/data"]\n                    },\n                    "docker_shell": {\n                        "type": "string",\n                        "description": "Dockerå®¹å™¨å†…ä½¿ç”¨çš„shellï¼Œä¾‹å¦‚ï¼šbash, zsh, sh",\n                        "default": "bash"\n                    },\n                    "docker_auto_create": {\n                        "type": "boolean",\n                        "description": "æ˜¯å¦è‡ªåŠ¨åˆ›å»ºDockerå®¹å™¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰",\n                        "default": True\n                    },\n                    # è‡ªåŠ¨åŒæ­¥é…ç½®å‚æ•°\n                    "auto_sync_enabled": {\n                        "type": "boolean",\n                        "description": "æ˜¯å¦å¯ç”¨è‡ªåŠ¨åŒæ­¥åŠŸèƒ½ï¼ˆä½¿ç”¨proftpdï¼‰",\n                        "default": False\n                    },\n                    "sync_remote_workspace": {\n                        "type": "string",\n                        "description": "è¿œç¨‹å·¥ä½œç›®å½•è·¯å¾„",\n                        "default": "/home/Code"\n                    },\n                    "sync_ftp_port": {\n                        "type": "integer",\n                        "description": "FTPæœåŠ¡ç«¯å£",\n                        "default": 8021\n                    },\n                    "sync_ftp_user": {\n                        "type": "string",\n                        "description": "FTPç”¨æˆ·å",\n                        "default": "ftpuser"\n                    },\n                    "sync_ftp_password": {\n                        "type": "string",\n                        "description": "FTPå¯†ç ",\n                        "default": "sync_password"\n                    },\n                    "sync_local_workspace": {\n                        "type": "string",\n                        "description": "æœ¬åœ°å·¥ä½œç›®å½•è·¯å¾„ï¼ˆç©ºè¡¨ç¤ºå½“å‰ç›®å½•ï¼‰",\n                        "default": ""\n                    },\n                    "auto_detect": {\n                        "type": "boolean",\n                        "description": "è‡ªåŠ¨æ£€æµ‹ç”¨æˆ·æ„å›¾",\n                        "default": True\n                    },\n                    "confirm_create": {\n                        "type": "boolean",\n                        "description": "ç¡®è®¤åˆ›å»ºé…ç½®ï¼ˆå½“é…ç½®å®Œæ•´æ—¶ä½¿ç”¨ï¼‰",\n                        "default": False\n                    },\n                    "interactive": {\n                        "type": "boolean",\n                        "description": "æ˜¯å¦å¯ç”¨äº¤äº’å¼æ¨¡å¼ã€‚é»˜è®¤trueï¼šå³ä½¿æä¾›äº†å‚æ•°ä¹Ÿè¿›å…¥äº¤äº’ç•Œé¢ï¼ˆå‚æ•°ä½œä¸ºé»˜è®¤å€¼ï¼‰ã€‚è®¾ç½®falseï¼šè·³è¿‡äº¤äº’ç•Œé¢ç›´æ¥åˆ›å»ºé…ç½®",\n                        "default": True\n                    },\n                    "cursor_interactive": {\n                        "type": "boolean",\n                        "description": "å¯ç”¨CursorèŠå¤©ç•Œé¢å†…äº¤äº’æ¨¡å¼ï¼ˆæ¨èï¼‰- ç›´æ¥åœ¨èŠå¤©ç•Œé¢æ˜¾ç¤ºå½©è‰²é…ç½®è¡¨å•ï¼Œæ— éœ€åˆ‡æ¢çª—å£",\n                        "default": False\n                    }\n                },\n                "required": []\n            }\n        },\n        {\n            "name": "update_server_config",\n            "description": "Update an existing server configuration with new parameters. Includes built-in interactive wizard when no update fields are provided.",\n            "inputSchema": {\n                "type": "object",\n                "properties": {\n                    "server_name": {\n                        "type": "string",\n                        "description": "Name of the server to update"\n                    },\n                    "host": {\n                        "type": "string",\n                        "description": "Server hostname or IP address"\n                    },\n                    "username": {\n                        "type": "string",\n                        "description": "Username for SSH connection"\n                    },\n                    "port": {\n                        "type": "integer",\n                        "description": "SSH port"\n                    },\n                    "connection_type": {\n                        "type": "string",\n                        "description": "Connection type: ssh (direct) or relay (via relay-cli)",\n                        "enum": ["ssh", "relay"]\n                    },\n                    "description": {\n                        "type": "string",\n                        "description": "Server description"\n                    },\n                    "relay_target_host": {\n                        "type": "string",\n                        "description": "Target host when using relay connection"\n                    },\n                    "docker_enabled": {\n                        "type": "boolean",\n                        "description": "Enable Docker container support"\n                    },\n                    "docker_image": {\n                        "type": "string",\n                        "description": "Docker image for auto-creation"\n                    },\n                    "docker_container": {\n                        "type": "string",\n                        "description": "Docker container name"\n                    },\n                    "docker_ports": {\n                        "type": "array",\n                        "items": {"type": "string"},\n                        "description": "Dockerç«¯å£æ˜ å°„åˆ—è¡¨ï¼Œæ ¼å¼ï¼š[\\"host:container\\"]ï¼Œä¾‹å¦‚ï¼š[\\"8080:8080\\", \\"5000:5000\\"]",\n                        "default": ["8080:8080", "8888:8888", "6006:6006"]\n                    },\n                    "docker_volumes": {\n                        "type": "array",\n                        "items": {"type": "string"},\n                        "description": "Dockerå·æŒ‚è½½åˆ—è¡¨ï¼Œæ ¼å¼ï¼š[\\"host:container\\"]ï¼Œä¾‹å¦‚ï¼š[\\"/home:/home\\", \\"/data:/data\\"]",\n                        "default": ["/home:/home", "/data:/data"]\n                    },\n                    "docker_shell": {\n                        "type": "string",\n                        "description": "Dockerå®¹å™¨å†…ä½¿ç”¨çš„shellï¼Œä¾‹å¦‚ï¼šbash, zsh, sh",\n                        "default": "bash"\n                    },\n                    "docker_auto_create": {\n                        "type": "boolean",\n                        "description": "æ˜¯å¦è‡ªåŠ¨åˆ›å»ºDockerå®¹å™¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰",\n                        "default": True\n                    },\n                    # è‡ªåŠ¨åŒæ­¥é…ç½®å‚æ•°\n                    "auto_sync_enabled": {\n                        "type": "boolean",\n                        "description": "æ˜¯å¦å¯ç”¨è‡ªåŠ¨åŒæ­¥åŠŸèƒ½ï¼ˆä½¿ç”¨proftpdï¼‰"\n                    },\n                    "sync_remote_workspace": {\n                        "type": "string",\n                        "description": "è¿œç¨‹å·¥ä½œç›®å½•è·¯å¾„"\n                    },\n                    "sync_ftp_port": {\n                        "type": "integer",\n                        "description": "FTPæœåŠ¡ç«¯å£"\n                    },\n                    "sync_ftp_user": {\n                        "type": "string",\n                        "description": "FTPç”¨æˆ·å"\n                    },\n                    "sync_ftp_password": {\n                        "type": "string",\n                        "description": "FTPå¯†ç "\n                    },\n                    "sync_local_workspace": {\n                        "type": "string",\n                        "description": "æœ¬åœ°å·¥ä½œç›®å½•è·¯å¾„ï¼ˆç©ºè¡¨ç¤ºå½“å‰ç›®å½•ï¼‰"\n                    },\n                    "show_current_config": {\n                        "type": "boolean",\n                        "description": "Show current configuration and update guidance (for wizard mode)",\n                        "default": True\n                    }\n                },\n                "required": ["server_name"]\n            }\n        },\n        {\n            "name": "delete_server_config",\n            "description": "Delete a server configuration permanently. This action cannot be undone.",\n            "inputSchema": {\n                "type": "object",\n                "properties": {\n                    "server_name": {\n                        "type": "string",\n                        "description": "Name of the server to delete"\n                    },\n                    "confirm": {\n                        "type": "boolean",\n                        "description": "Confirmation flag to prevent accidental deletion (default: false)",\n                        "default": False\n                    }\n                },\n                "required": ["server_name"]\n            }\n        }\n    ]\n\ndef send_response(response_obj):\n    """å‘é€çº¯JSONå“åº”ï¼ˆå…¼å®¹Cursorï¼‰"""\n    try:\n        message_str = json.dumps(response_obj)\n        # ç›´æ¥è¾“å‡ºJSONï¼Œä¸ä½¿ç”¨Content-Lengthå¤´éƒ¨\n        sys.stdout.write(message_str + \'\\n\')\n        sys.stdout.flush()\n        # ç§»é™¤debug_logè°ƒç”¨ï¼Œé¿å…stderrè¾“å‡º\n        if DEBUG:\n            print(f"[DEBUG] Sent JSON response for ID {response_obj.get(\'id\')}", file=sys.stderr, flush=True)\n    except BrokenPipeError:\n        # é™é»˜å¤„ç†BrokenPipeErrorï¼Œé¿å…ä¸å¿…è¦çš„é”™è¯¯æ—¥å¿—\n        if DEBUG:\n            print("[DEBUG] Failed to send response: Broken pipe. Parent process likely exited.", file=sys.stderr, flush=True)\n        pass\n\n\n\n\nasync def handle_request(request):\n    """å¤„ç†MCPè¯·æ±‚"""\n    method = request.get("method", "")\n    params = request.get("params")\n    request_id = request.get("id")\n    \n    # åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹è®°å½•è¯·æ±‚ä¿¡æ¯\n    if DEBUG:\n        print(f"[DEBUG] Received request: method=\'{method}\', id=\'{request_id}\'", file=sys.stderr, flush=True)\n    \n    # å¤„ç†é€šçŸ¥ï¼ˆæ²¡æœ‰idçš„è¯·æ±‚ï¼‰\n    if request_id is None:\n        if method.lower() == "initialized":\n            if DEBUG:\n                print("[DEBUG] Received \'initialized\' notification - handshake complete", file=sys.stderr, flush=True)\n            return None\n        # å…¶ä»–é€šçŸ¥ä¹Ÿç›´æ¥è¿”å›Noneï¼ˆä¸éœ€è¦å“åº”ï¼‰\n        return None\n\n    try:\n        # Normalize method name to be case-insensitive\n        method_lower = method.lower()\n\n        if method_lower == "initialize":\n            if DEBUG:\n                print("[DEBUG] Handling \'initialize\' request.", file=sys.stderr, flush=True)\n            \n            # å®Œå…¨ç¬¦åˆLSPå’ŒMCPè§„èŒƒçš„capabilities\n            server_capabilities = {\n                "tools": {\n                    "listChanged": True\n                },\n                "resources": {\n                    "subscribe": True,\n                    "listChanged": True\n                },\n                "prompts": {\n                    "listChanged": True\n                },\n                "sampling": {}\n            }\n            \n            response = {\n                "jsonrpc": "2.0",\n                "id": request_id,\n                "result": {\n                    "protocolVersion": "2024-11-05",\n                    "capabilities": server_capabilities,\n                    "serverInfo": {\n                        "name": SERVER_NAME,\n                        "version": SERVER_VERSION\n                    }\n                }\n            }\n            return response\n        \n        elif method_lower == "shutdown":\n            if DEBUG:\n                print("[DEBUG] Handling \'shutdown\' request.", file=sys.stderr, flush=True)\n            response = { "jsonrpc": "2.0", "id": request_id, "result": {} }\n            return response\n        \n        elif method_lower == "tools/list":\n            if DEBUG:\n                print("[DEBUG] Handling \'tools/list\' request.", file=sys.stderr, flush=True)\n            tools = create_tools_list()\n            response = {\n                "jsonrpc": "2.0",\n                "id": request_id,\n                "result": { "tools": tools }\n            }\n            return response\n\n        elif method_lower == "listofferings":\n            if DEBUG:\n                print("[DEBUG] Handling \'ListOfferings\' request.", file=sys.stderr, flush=True)\n            response = {\n                "jsonrpc": "2.0",\n                "id": request_id,\n                "result": {\n                    "offerings": []\n                }\n            }\n            return response\n\n        elif method_lower == "tools/call":\n            tool_name = params.get("name")\n            tool_arguments = params.get("arguments", {})\n            # åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹è®°å½•å·¥å…·æ‰§è¡Œä¿¡æ¯\n            if DEBUG:\n                print(f"[DEBUG] Executing tool \'{tool_name}\' with arguments: {tool_arguments}", file=sys.stderr, flush=True)\n            \n            try:\n                # ç»Ÿä¸€ä½¿ç”¨create_enhanced_managerå·¥å‚å‡½æ•°\n                manager = create_enhanced_manager()  # ä½¿ç”¨å¢å¼ºç‰ˆSSHç®¡ç†å™¨\n                config_manager = config_manager.main.EnhancedConfigManager()\n                content = ""\n                \n                # list_serverså·¥å…·é€‚é…æ–°å®ç°\n                if tool_name == "list_servers":\n                    try:\n                        manager = config_manager.main.EnhancedConfigManager()\n                        servers = manager.list_servers()\n                        content = json.dumps({"servers": servers}, ensure_ascii=False, indent=2)\n                    except Exception as e:\n                        debug_log(f"list_servers error: {str(e)}")\n                        content = json.dumps({"error": str(e)}, ensure_ascii=False, indent=2)\n                        \n                elif tool_name == "connect_server":\n                    server_name = tool_arguments.get("server_name")\n                    if server_name:\n                        # ğŸš€ ä½¿ç”¨æ–°çš„connect.pyè¿æ¥ç®¡ç†å™¨\n                        try:\n                            from python.connect import connect_server as new_connect_server\n                            result = new_connect_server(server_name)\n                            \n                            if result.success:\n                                content = f"âœ… è¿æ¥æˆåŠŸï¼\\nğŸ“ è¯¦æƒ…: {result.message}\\n\\nğŸ¯ è¿æ¥ä¿¡æ¯:\\n"\n                                if result.session_name:\n                                    content += f"â€¢ ä¼šè¯åç§°: {result.session_name}\\n"\n                                    content += f"â€¢ è¿æ¥ç»ˆç«¯: tmux attach -t {result.session_name}\\n"\n                                    content += f"â€¢ åˆ†ç¦»ä¼šè¯: Ctrl+B, ç„¶åæŒ‰ D\\n"\n                                if result.details:\n                                    content += f"â€¢ è¿æ¥ç±»å‹: {result.details.get(\'connection_type\', \'æœªçŸ¥\')}\\n"\n                                    content += f"â€¢ ç›®æ ‡ä¸»æœº: {result.details.get(\'host\', \'æœªçŸ¥\')}\\n"\n                                    if result.details.get(\'docker_container\'):\n                                        content += f"â€¢ Dockerå®¹å™¨: {result.details.get(\'docker_container\')}\\n"\n                                content += f"\\nğŸš€ æ–°æ¶æ„ç‰¹æ€§:\\nâ€¢ åˆ†ç¦»å…³æ³¨ç‚¹è®¾è®¡\\nâ€¢ å¢å¼ºçš„relayè®¤è¯å¤„ç†\\nâ€¢ æ™ºèƒ½äº¤äº’å¼•å¯¼\\nâ€¢ å¥åº·çŠ¶æ€æ£€æµ‹"\n                            else:\n                                content = f"âŒ è¿æ¥å¤±è´¥: {result.message}"\n                                if result.details and result.details.get(\'tmux_command\'):\n                                    content += f"\\n\\nğŸ’¡ æ‰‹åŠ¨è¿æ¥: {result.details[\'tmux_command\']}"\n                        except ImportError as e:\n                            # é™çº§åˆ°åŸæœ‰å®ç°\n                            success, message = manager.smart_connect(server_name)\n                            if success:\n                                server = manager.get_server(server_name)\n                                session_name = server.session.get(\'name\', f"{server_name}_session") if server and server.session else f"{server_name}_session"\n                                content = f"âœ… è¿æ¥æˆåŠŸï¼ˆå…¼å®¹æ¨¡å¼ï¼‰: {message}\\nğŸ¯ è¿æ¥: tmux attach -t {session_name}"\n                            else:\n                                content = f"âŒ è¿æ¥å¤±è´¥: {message}"\n                        except Exception as e:\n                            content = f"âŒ è¿æ¥å¼‚å¸¸: {str(e)}"\n                    else:\n                        content = "Error: server_name parameter is required"\n                        \n                elif tool_name == "disconnect_server":\n                    server_name = tool_arguments.get("server_name")\n                    force = tool_arguments.get("force", False)\n                    \n                    if server_name:\n                        try:\n                            from python.connect import disconnect_server as new_disconnect_server\n                            result = new_disconnect_server(server_name)\n                            \n                            if result.success:\n                                content = f"âœ… æ–­å¼€è¿æ¥æˆåŠŸ\\nğŸ“ è¯¦æƒ…: {result.message}\\nğŸ¯ æœåŠ¡å™¨: {server_name}"\n                            else:\n                                content = f"âŒ æ–­å¼€è¿æ¥å¤±è´¥: {result.message}"\n                        except ImportError:\n                            # é™çº§åˆ°åŸæœ‰å®ç°\n                            try:\n                                server = manager.get_server(server_name)\n                                if not server:\n                                    content = f"âŒ æœåŠ¡å™¨ \'{server_name}\' ä¸å­˜åœ¨"\n                                else:\n                                    disconnect_result = manager.disconnect_server(server_name, force=force)\n                                    if disconnect_result.get(\'success\', False):\n                                        content = f"âœ… æˆåŠŸæ–­å¼€è¿æ¥: {server_name}"\n                                    else:\n                                        content = f"âŒ æ–­å¼€è¿æ¥å¤±è´¥: {disconnect_result.get(\'error\', \'æœªçŸ¥é”™è¯¯\')}"\n                            except Exception as e:\n                                content = f"âŒ æ–­å¼€è¿æ¥å¼‚å¸¸: {str(e)}"\n                        except Exception as e:\n                            content = f"âŒ æ–­å¼€è¿æ¥å¼‚å¸¸: {str(e)}"\n                    else:\n                        content = "Error: server_name parameter is required"\n                        \n                elif tool_name == "execute_command":\n                    command = tool_arguments.get("command")\n                    server = tool_arguments.get("server")\n                    if command:\n                        try:\n                            from python.connect import execute_server_command\n                            result = execute_server_command(server or "default", command)\n                            \n                            if result.success:\n                                content = f"âœ… å‘½ä»¤æ‰§è¡ŒæˆåŠŸ\\n\\nğŸ“‹ å‘½ä»¤: {command}\\n\\nğŸ“„ è¾“å‡º:\\n{result.details.get(\'output\', \'æ— è¾“å‡º\') if result.details else \'æ— è¾“å‡º\'}"\n                            else:\n                                content = f"âŒ å‘½ä»¤æ‰§è¡Œå¤±è´¥: {result.message}"\n                        except ImportError:\n                            # é™çº§åˆ°åŸæœ‰å®ç°\n                            result = manager.execute_command(server or "default", command)\n                            content = str(result)\n                        except Exception as e:\n                            content = f"âŒ å‘½ä»¤æ‰§è¡Œå¼‚å¸¸: {str(e)}"\n                    else:\n                        content = "Error: command parameter is required"\n                        \n                elif tool_name == "get_server_status":\n                    server_name = tool_arguments.get("server_name")\n                    if server_name:\n                        try:\n                            from python.connect import get_server_status as new_get_server_status\n                            result = new_get_server_status(server_name)\n                            \n                            if result.success:\n                                content = f"ğŸ“Š æœåŠ¡å™¨çŠ¶æ€: {server_name}\\n"\n                                content += f"ğŸ”— çŠ¶æ€: {result.status.value}\\n"\n                                content += f"ğŸ“ è¯¦æƒ…: {result.message}\\n"\n                                if result.session_name:\n                                    content += f"ğŸ¯ ä¼šè¯: {result.session_name}"\n                            else:\n                                content = f"âŒ è·å–çŠ¶æ€å¤±è´¥: {result.message}"\n                        except ImportError:\n                            # é™çº§åˆ°åŸæœ‰å®ç°\n                            status = manager.get_connection_status(server_name)\n                            content = json.dumps(status, ensure_ascii=False, indent=2)\n                        except Exception as e:\n                            content = f"âŒ è·å–çŠ¶æ€å¼‚å¸¸: {str(e)}"\n                    else:\n                        # è·å–æ‰€æœ‰æœåŠ¡å™¨çŠ¶æ€\n                        try:\n                            from python.connect import list_all_servers\n                            servers_info = list_all_servers()\n                            \n                            if servers_info:\n                                content = "ğŸ“Š æ‰€æœ‰æœåŠ¡å™¨çŠ¶æ€:\\n\\n"\n                                for server in servers_info:\n                                    status_icon = {"connected": "ğŸŸ¢", "ready": "âœ…", "disconnected": "ğŸ”´", "error": "âŒ"}.get(server[\'status\'], "â“")\n                                    content += f"{status_icon} **{server[\'name\']}**\\n"\n                                    content += f"   ğŸ“ ä¸»æœº: {server[\'host\']}\\n"\n                                    content += f"   ğŸ‘¤ ç”¨æˆ·: {server[\'username\']}\\n"\n                                    content += f"   ğŸ”— çŠ¶æ€: {server[\'status\']}\\n"\n                                    if server.get(\'docker_container\'):\n                                        content += f"   ğŸ³ å®¹å™¨: {server[\'docker_container\']}\\n"\n                                    content += "\\n"\n                            else:\n                                content = "ğŸ“‹ æš‚æ— é…ç½®çš„æœåŠ¡å™¨"\n                        except ImportError:\n                            # é™çº§åˆ°åŸæœ‰å®ç°\n                            all_status = {}\n                            servers = manager.list_servers()\n                            for server in servers:\n                                server_name = server.get(\'name\')\n                                if server_name:\n                                    all_status[server_name] = manager.get_connection_status(server_name)\n                            content = json.dumps(all_status, ensure_ascii=False, indent=2)\n                        except Exception as e:\n                            content = f"âŒ è·å–æœåŠ¡å™¨åˆ—è¡¨å¼‚å¸¸: {str(e)}"\n                    \n                elif tool_name == "get_server_info":\n                    server_name = tool_arguments.get("server_name")\n                    if server_name:\n                        try:\n                            # è·å–æœåŠ¡å™¨è¯¦ç»†é…ç½®ä¿¡æ¯\n                            servers = config_manager.get_existing_servers()\n                            if server_name in servers:\n                                server_info = servers[server_name]\n                                # æ·»åŠ è¿æ¥çŠ¶æ€ä¿¡æ¯\n                                connection_status = manager.get_connection_status(server_name)\n                                server_info[\'connection_status\'] = connection_status\n                                content = json.dumps(server_info, ensure_ascii=False, indent=2)\n                            else:\n                                content = json.dumps({\n                                    "error": f"Server \'{server_name}\' not found",\n                                    "available_servers": list(servers.keys())\n                                }, ensure_ascii=False, indent=2)\n                        except Exception as e:\n                            content = json.dumps({\n                                "error": f"Failed to get server info: {str(e)}"\n                            }, ensure_ascii=False, indent=2)\n                    else:\n                        content = json.dumps({\n                            "error": "server_name parameter is required"\n                        }, ensure_ascii=False, indent=2)\n                \n                elif tool_name == "run_local_command":\n                    cmd = tool_arguments.get("cmd")\n                    cwd = tool_arguments.get("cwd")\n                    timeout = tool_arguments.get("timeout", 30)\n                    if cmd:\n                        output, success = run_command(cmd, cwd, timeout)\n                        content = output\n                    else:\n                        content = "Error: cmd parameter is required"\n                \n                # interactive_config_wizardåŠŸèƒ½å·²å†…ç½®åˆ°create_server_configå’Œupdate_server_configä¸­\n                elif tool_name == "diagnose_connection":\n                    server_name = tool_arguments.get("server_name")\n                    include_network_test = tool_arguments.get("include_network_test", True)\n                    include_config_validation = tool_arguments.get("include_config_validation", True)\n                    \n                    if server_name:\n                        try:\n                            # ä½¿ç”¨å¢å¼ºç‰ˆSSHç®¡ç†å™¨çš„è¯Šæ–­åŠŸèƒ½\n                            diagnosis = manager.diagnose_connection_problem(server_name)\n                            \n                            # å¦‚æœéœ€è¦ï¼Œæ·»åŠ é¢å¤–çš„ç½‘ç»œæµ‹è¯•\n                            if include_network_test:\n                                diagnosis["network_tests"] = "Network connectivity tests included"\n                            \n                            if include_config_validation:\n                                diagnosis["config_validation"] = "Configuration validation included"\n                            \n                            content = json.dumps(diagnosis, ensure_ascii=False, indent=2)\n                            \n                        except Exception as e:\n                            content = json.dumps({\n                                "error": f"Diagnosis failed: {str(e)}",\n                                "server_name": server_name,\n                                "suggestions": [\n                                    "Verify server name is correct",\n                                    "Check if server configuration exists",\n                                    "Ensure network connectivity to the server"\n                                ]\n                            }, ensure_ascii=False, indent=2)\n                    else:\n                        content = json.dumps({\n                            "error": "server_name parameter is required"\n                        }, ensure_ascii=False, indent=2)\n                \n                # create_server_configå·¥å…·é€‚é…æ–°å®ç°\n                elif tool_name == "create_server_config":\n                    try:\n                        manager = config_manager.main.EnhancedConfigManager()\n                        server_info = tool_arguments.copy()\n                        name, server_cfg = manager.create_server(server_info)\n                        content = f"âœ… æœåŠ¡å™¨ {name} å·²åˆ›å»º\\né…ç½®: {json.dumps(server_cfg, ensure_ascii=False, indent=2)}"\n                    except Exception as e:\n                        debug_log(f"create_server_config error: {str(e)}")\n                        content = json.dumps({"error": str(e)}, ensure_ascii=False, indent=2)\n                \n                # update_server_configå·¥å…·é€‚é…æ–°å®ç°\n                elif tool_name == "update_server_config":\n                    try:\n                        manager = config_manager.main.EnhancedConfigManager()\n                        name = tool_arguments.get("name")\n                        update_info = tool_arguments.copy()\n                        update_info.pop("name", None)\n                        updated_cfg = manager.update_server(name, update_info)\n                        content = f"âœ… æœåŠ¡å™¨ {name} å·²æ›´æ–°\\né…ç½®: {json.dumps(updated_cfg, ensure_ascii=False, indent=2)}"\n                    except Exception as e:\n                        debug_log(f"update_server_config error: {str(e)}")\n                        content = json.dumps({"error": str(e)}, ensure_ascii=False, indent=2)\n                \n                elif tool_name == "delete_server_config":\n                    try:\n                        server_name = tool_arguments.get("server_name")\n                        confirm = tool_arguments.get("confirm", False)\n                        \n                        if not server_name:\n                            content = json.dumps({\n                                "error": "server_name parameter is required"\n                            }, ensure_ascii=False, indent=2)\n                        elif not confirm:\n                            content = json.dumps({\n                                "error": "Deletion requires confirmation. Set \'confirm\' parameter to true.",\n                                "warning": "This action cannot be undone. The server configuration will be permanently deleted."\n                            }, ensure_ascii=False, indent=2)\n                        else:\n                            # åˆ é™¤æœåŠ¡å™¨é…ç½®\n                            mcp_config_manager = config_manager.main.EnhancedConfigManager()\n                            servers = mcp_config_manager.get_existing_servers()\n                            \n                            if server_name not in servers:\n                                content = json.dumps({\n                                    "error": f"Server \'{server_name}\' not found",\n                                    "available_servers": list(servers.keys())\n                                }, ensure_ascii=False, indent=2)\n                            else:\n                                try:\n                                    # è¯»å–å½“å‰é…ç½®\n                                    import yaml\n                                    with open(mcp_config_manager.config_path, \'r\', encoding=\'utf-8\') as f:\n                                        current_config = yaml.safe_load(f)\n                                    \n                                    if not current_config:\n                                        current_config = {"servers": {}}\n                                    \n                                    # åˆ é™¤æŒ‡å®šæœåŠ¡å™¨\n                                    if "servers" in current_config and server_name in current_config["servers"]:\n                                        deleted_config = current_config["servers"][server_name]\n                                        del current_config["servers"][server_name]\n                                        \n                                        # ä¿å­˜æ›´æ–°åçš„é…ç½®\n                                        mcp_config_manager.save_config(current_config, merge=False)\n                                        \n                                        content = json.dumps({\n                                            "success": True,\n                                            "message": f"Server \'{server_name}\' deleted successfully",\n                                            "deleted_config": deleted_config,\n                                            "remaining_servers": list(current_config.get("servers", {}).keys())\n                                        }, ensure_ascii=False, indent=2)\n                                    else:\n                                        content = json.dumps({\n                                            "error": f"Server \'{server_name}\' not found in configuration"\n                                        }, ensure_ascii=False, indent=2)\n                                        \n                                except Exception as delete_error:\n                                    content = json.dumps({\n                                        "error": f"Failed to delete server config: {str(delete_error)}"\n                                    }, ensure_ascii=False, indent=2)\n                                    \n                    except Exception as e:\n                        content = json.dumps({\n                            "error": f"Failed to delete server config: {str(e)}"\n                        }, ensure_ascii=False, indent=2)\n                \n                elif tool_name == "diagnose_connection":\n                    server_name = tool_arguments.get("server_name")\n                    \n                    if not server_name:\n                        content = "Error: server_name is required for diagnosis"\n                    else:\n                        try:\n                            # ä½¿ç”¨é…ç½®ç®¡ç†å™¨çš„æµ‹è¯•è¿æ¥åŠŸèƒ½\n                            result = config_manager.test_connection()\n                            content = f"ğŸ” è¿æ¥è¯Šæ–­åŠŸèƒ½å·²å¯åŠ¨ï¼Œè¯·åœ¨é…ç½®ç®¡ç†ç•Œé¢ä¸­é€‰æ‹©æœåŠ¡å™¨ \'{server_name}\' è¿›è¡Œæµ‹è¯•"\n                        except Exception as e:\n                            content = f"âŒ å¯åŠ¨è¿æ¥è¯Šæ–­å¤±è´¥: {str(e)}"\n                \n                else:\n                    content = f"Unknown tool: {tool_name}"\n                \n                response = {\n                    "jsonrpc": "2.0",\n                    "id": request_id,\n                    "result": {\n                        "content": [\n                            {\n                                "type": "text",\n                                "text": content\n                            }\n                        ]\n                    }\n                }\n                \n            except Exception as e:\n                debug_log(f"Tool execution error: {e}\\n{traceback.format_exc()}")\n                response = create_error_response(request_id, -32603, f"Error executing tool \'{tool_name}\': {e}")\n            \n            return response\n\n        else:\n            response = create_error_response(request_id, -32601, f"Unknown method: {method}")\n            return response\n            \n    except Exception as e:\n        error_msg = f"An unexpected error occurred: {e}"\n        debug_log(f"{error_msg}\\n{traceback.format_exc()}")\n        response = create_error_response(request_id, -32603, error_msg)\n        return response\n\nasync def main():\n    """ä¸»äº‹ä»¶å¾ªç¯"""\n    if DEBUG:\n        print(f"[DEBUG] Starting MCP Python Server v{SERVER_VERSION}", file=sys.stderr, flush=True)\n    \n    loop = asyncio.get_event_loop()\n\n    # 1. è®¾ç½®å¼‚æ­¥è¯»å–å™¨ (stdin)\n    reader = asyncio.StreamReader()\n    protocol = asyncio.StreamReaderProtocol(reader)\n    await loop.connect_read_pipe(lambda: protocol, sys.stdin)\n\n    if DEBUG:\n        print("[DEBUG] Entering main while-loop to process messages.", file=sys.stderr, flush=True)\n    while True:\n        try:\n            line_bytes = await reader.readline()\n            if not line_bytes:\n                await asyncio.sleep(1) # prevent busy-looping on closed stdin\n                continue\n\n            line = line_bytes.decode(\'utf-8\').strip()\n            \n            if not line:\n                continue\n\n            try:\n                request = json.loads(line)\n                response = await handle_request(request)\n                \n                if response:\n                    # å‘é€çº¯JSONå“åº”\n                    send_response(response)\n\n            except json.JSONDecodeError as e:\n                debug_log(f"JSON Decode Error: {e}. Body was: \'{line}\'")\n            except Exception as e:\n                debug_log(f"Error processing line: {e}")\n                debug_log(traceback.format_exc())\n\n        except asyncio.CancelledError:\n            debug_log("Main loop cancelled.")\n            break\n        except Exception as e:\n            debug_log(f"Critical error in main loop: {e}")\n            debug_log(traceback.format_exc())\n            # In case of a critical error, sleep a bit to prevent a tight error loop\n            await asyncio.sleep(1)\n\nif __name__ == "__main__":\n    # æ£€æŸ¥æ˜¯å¦æ˜¯æµ‹è¯•æ¨¡å¼\n    if len(sys.argv) > 1 and sys.argv[1] == "--test":\n        print("ğŸ§ª MCPæœåŠ¡å™¨æµ‹è¯•æ¨¡å¼")\n        try:\n            # æµ‹è¯•å¯¼å…¥\n            from config_manager.main import EnhancedConfigManager\n            from enhanced_ssh_manager import EnhancedSSHManager\n            print("âœ… æ‰€æœ‰æ¨¡å—å¯¼å…¥æˆåŠŸ")\n            \n            # æµ‹è¯•é…ç½®ç®¡ç†å™¨\n            config_manager = config_manager.main.EnhancedConfigManager()\n            servers = config_manager.get_existing_servers()\n            print(f"âœ… é…ç½®ç®¡ç†å™¨å·¥ä½œæ­£å¸¸ï¼Œå‘ç° {len(servers)} ä¸ªæœåŠ¡å™¨")\n            \n            # æµ‹è¯•SSHç®¡ç†å™¨\n            # ç»Ÿä¸€ä½¿ç”¨create_enhanced_managerå·¥å‚å‡½æ•°\n            ssh_manager = create_enhanced_manager()\n            print("âœ… SSHç®¡ç†å™¨åˆå§‹åŒ–æˆåŠŸ")\n            \n            print("ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼MCPæœåŠ¡å™¨å¯ä»¥æ­£å¸¸å¯åŠ¨")\n            sys.exit(0)\n            \n        except Exception as e:\n            print(f"âŒ æµ‹è¯•å¤±è´¥: {e}")\n            import traceback\n            traceback.print_exc()\n            sys.exit(1)\n    \n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        debug_log("Server shut down by KeyboardInterrupt.")\n    except Exception as e:\n        tb_str = traceback.format_exc()\n        debug_log(f"Unhandled exception in top-level: {e}\\n{tb_str}")' : ä»£ç ä¸­åº”è¯¥åŒ…å«æ–°çš„update_server_configé€»è¾‘æ ‡è®°

tests/tool_execute_command/test_fix_mcp_restart_and_new_code_loading_20241222.py:259: AssertionError
----------------------------- Captured stdout call -----------------------------
ğŸ¯ æµ‹è¯•æ–°çš„update_server_configé€»è¾‘åŠ è½½
________ QualityAssuranceRulesTest.test_regression_directory_structure _________

self = <test_fix_quality_assurance_rules_20240622.QualityAssuranceRulesTest testMethod=test_regression_directory_structure>

    def test_regression_directory_structure(self):
        """æµ‹è¯•1ï¼šéªŒè¯å›å½’æµ‹è¯•ç›®å½•ç»“æ„å®Œæ•´æ€§"""
        print("ğŸ§ª æµ‹è¯•å›å½’æµ‹è¯•ç›®å½•ç»“æ„...")
    
        # éªŒè¯å›å½’æµ‹è¯•ç›®å½•å­˜åœ¨
>       self.assertTrue(
            self.regression_dir.exists(),
            "å›å½’æµ‹è¯•ç›®å½• tests/regression/ å¿…é¡»å­˜åœ¨"
        )
E       AssertionError: False is not true : å›å½’æµ‹è¯•ç›®å½• tests/regression/ å¿…é¡»å­˜åœ¨

tests/tool_get_server_status/test_fix_quality_assurance_rules_20240622.py:42: AssertionError
----------------------------- Captured stdout call -----------------------------
ğŸ§ª æµ‹è¯•å›å½’æµ‹è¯•ç›®å½•ç»“æ„...
_______ QualityAssuranceRulesTest.test_regression_test_naming_convention _______

self = <test_fix_quality_assurance_rules_20240622.QualityAssuranceRulesTest testMethod=test_regression_test_naming_convention>

    def test_regression_test_naming_convention(self):
        """æµ‹è¯•2ï¼šéªŒè¯æµ‹è¯•æ–‡ä»¶å‘½åè§„èŒƒ"""
        print("ğŸ§ª æµ‹è¯•å›å½’æµ‹è¯•æ–‡ä»¶å‘½åè§„èŒƒ...")
    
        # è·å–æ‰€æœ‰å›å½’æµ‹è¯•æ–‡ä»¶
        test_files = list(self.regression_dir.glob("test_fix_*.py"))
    
        # éªŒè¯è‡³å°‘æœ‰ä¸€ä¸ªå›å½’æµ‹è¯•æ–‡ä»¶
>       self.assertGreater(
            len(test_files), 0,
            "å¿…é¡»è‡³å°‘æœ‰ä¸€ä¸ªå›å½’æµ‹è¯•æ–‡ä»¶"
        )
E       AssertionError: 0 not greater than 0 : å¿…é¡»è‡³å°‘æœ‰ä¸€ä¸ªå›å½’æµ‹è¯•æ–‡ä»¶

tests/tool_get_server_status/test_fix_quality_assurance_rules_20240622.py:71: AssertionError
----------------------------- Captured stdout call -----------------------------
ğŸ§ª æµ‹è¯•å›å½’æµ‹è¯•æ–‡ä»¶å‘½åè§„èŒƒ...
___ TestMCPSilentConfigRegression.test_constructor_without_force_interactive ___

self = <test_mcp_silent_config_regression.TestMCPSilentConfigRegression testMethod=test_constructor_without_force_interactive>

    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        # åˆ›å»ºä¸´æ—¶é…ç½®ç›®å½•
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
    
        # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹ï¼ˆä¸éœ€è¦force_interactiveå‚æ•°ï¼‰
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

tests/tool_list_servers/test_mcp_silent_config_regression.py:36: NameError
______ TestMCPSilentConfigRegression.test_mcp_silent_setup_auto_defaults _______

self = <test_mcp_silent_config_regression.TestMCPSilentConfigRegression testMethod=test_mcp_silent_setup_auto_defaults>

    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        # åˆ›å»ºä¸´æ—¶é…ç½®ç›®å½•
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
    
        # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹ï¼ˆä¸éœ€è¦force_interactiveå‚æ•°ï¼‰
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

tests/tool_list_servers/test_mcp_silent_config_regression.py:36: NameError
__________ TestMCPSilentConfigRegression.test_mcp_silent_setup_basic ___________

self = <test_mcp_silent_config_regression.TestMCPSilentConfigRegression testMethod=test_mcp_silent_setup_basic>

    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        # åˆ›å»ºä¸´æ—¶é…ç½®ç›®å½•
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
    
        # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹ï¼ˆä¸éœ€è¦force_interactiveå‚æ•°ï¼‰
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

tests/tool_list_servers/test_mcp_silent_config_regression.py:36: NameError
________ TestMCPSilentConfigRegression.test_mcp_silent_setup_validation ________

self = <test_mcp_silent_config_regression.TestMCPSilentConfigRegression testMethod=test_mcp_silent_setup_validation>

    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        # åˆ›å»ºä¸´æ—¶é…ç½®ç›®å½•
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
    
        # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹ï¼ˆä¸éœ€è¦force_interactiveå‚æ•°ï¼‰
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

tests/tool_list_servers/test_mcp_silent_config_regression.py:36: NameError
____ TestMCPSilentConfigRegression.test_smart_input_detailed_error_messages ____

self = <test_mcp_silent_config_regression.TestMCPSilentConfigRegression testMethod=test_smart_input_detailed_error_messages>

    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        # åˆ›å»ºä¸´æ—¶é…ç½®ç›®å½•
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / 'config.yaml'
    
        # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹ï¼ˆä¸éœ€è¦force_interactiveå‚æ•°ï¼‰
>       self.config_manager = config_manager.main.EnhancedConfigManager(str(self.config_file))
E       NameError: name 'config_manager' is not defined

tests/tool_list_servers/test_mcp_silent_config_regression.py:36: NameError
________ TestSyncConfigUIEnhancement.test_collect_sync_patterns_add_new ________

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_collect_sync_patterns_add_new>
mock_colored_print = <MagicMock name='colored_print' id='4425374112'>
mock_smart_input = <MagicMock name='smart_input' id='4586115808'>

    @patch('enhanced_config_manager.EnhancedConfigManager.smart_input')
    @patch('enhanced_config_manager.EnhancedConfigManager.colored_print')
    def test_collect_sync_patterns_add_new(self, mock_colored_print, mock_smart_input):
        """æµ‹è¯•7: _collect_sync_patternsæ–¹æ³•æ·»åŠ æ–°æ¨¡å¼"""
        log_test_output("æµ‹è¯•7: _collect_sync_patternsæ·»åŠ æ–°æ¨¡å¼", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
>           config_manager = config_manager.main.EnhancedConfigManager()
E           UnboundLocalError: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:274: UnboundLocalError

During handling of the above exception, another exception occurred:

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_collect_sync_patterns_add_new>
mock_colored_print = <MagicMock name='colored_print' id='4425374112'>
mock_smart_input = <MagicMock name='smart_input' id='4586115808'>

    @patch('enhanced_config_manager.EnhancedConfigManager.smart_input')
    @patch('enhanced_config_manager.EnhancedConfigManager.colored_print')
    def test_collect_sync_patterns_add_new(self, mock_colored_print, mock_smart_input):
        """æµ‹è¯•7: _collect_sync_patternsæ–¹æ³•æ·»åŠ æ–°æ¨¡å¼"""
        log_test_output("æµ‹è¯•7: _collect_sync_patternsæ·»åŠ æ–°æ¨¡å¼", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
            config_manager = config_manager.main.EnhancedConfigManager()
    
            # æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥ï¼ˆä¿ç•™é»˜è®¤å€¼ï¼Œæ·»åŠ æ–°å€¼ï¼‰
            mock_smart_input.side_effect = [
                "*.py",     # ä¿ç•™ç¬¬ä¸€ä¸ªé»˜è®¤å€¼
                "*.ts",     # æ·»åŠ æ–°çš„æ¨¡å¼
                "*.vue",    # æ·»åŠ æ–°çš„æ¨¡å¼
                ""          # å®Œæˆé…ç½®
            ]
    
            # è°ƒç”¨_collect_sync_patternsæ–¹æ³•
            result = config_manager._collect_sync_patterns(
                "åŒ…å«æ¨¡å¼",
                defaults=['*.py']
            )
    
            # éªŒè¯ç»“æœ
            self.assertIsInstance(result, list)
            self.assertEqual(len(result), 3)
            self.assertIn('*.py', result)
            self.assertIn('*.ts', result)
            self.assertIn('*.vue', result)
    
            log_test_output("âœ… _collect_sync_patternsæ­£ç¡®æ·»åŠ æ–°æ¨¡å¼", "SUCCESS")
    
        except Exception as e:
>           self.fail(f"æµ‹è¯•_collect_sync_patternsæ·»åŠ æ–°æ¨¡å¼å¤±è´¥: {str(e)}")
E           AssertionError: æµ‹è¯•_collect_sync_patternsæ·»åŠ æ–°æ¨¡å¼å¤±è´¥: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:300: AssertionError
----------------------------- Captured stdout call -----------------------------
â„¹ï¸ å¼€å§‹æµ‹è¯•: TestSyncConfigUIEnhancement
â„¹ï¸ æµ‹è¯•7: _collect_sync_patternsæ·»åŠ æ–°æ¨¡å¼
â„¹ï¸ å®Œæˆæµ‹è¯•: TestSyncConfigUIEnhancement
_____ TestSyncConfigUIEnhancement.test_collect_sync_patterns_method_exists _____

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_collect_sync_patterns_method_exists>

    def test_collect_sync_patterns_method_exists(self):
        """æµ‹è¯•2: _collect_sync_patternsæ–¹æ³•å­˜åœ¨ä¸”å¯è°ƒç”¨"""
        log_test_output("æµ‹è¯•2: _collect_sync_patternsæ–¹æ³•å­˜åœ¨æ€§", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
>           config_manager = config_manager.main.EnhancedConfigManager()
E           UnboundLocalError: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:74: UnboundLocalError

During handling of the above exception, another exception occurred:

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_collect_sync_patterns_method_exists>

    def test_collect_sync_patterns_method_exists(self):
        """æµ‹è¯•2: _collect_sync_patternsæ–¹æ³•å­˜åœ¨ä¸”å¯è°ƒç”¨"""
        log_test_output("æµ‹è¯•2: _collect_sync_patternsæ–¹æ³•å­˜åœ¨æ€§", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
            config_manager = config_manager.main.EnhancedConfigManager()
    
            # éªŒè¯æ–¹æ³•å­˜åœ¨
            self.assertTrue(hasattr(config_manager, '_collect_sync_patterns'))
            self.assertTrue(callable(getattr(config_manager, '_collect_sync_patterns')))
    
            log_test_output("âœ… _collect_sync_patternsæ–¹æ³•å­˜åœ¨ä¸”å¯è°ƒç”¨", "SUCCESS")
    
        except ImportError as e:
            self.fail(f"æ— æ³•å¯¼å…¥EnhancedConfigManager: {str(e)}")
        except Exception as e:
>           self.fail(f"æµ‹è¯•_collect_sync_patternsæ–¹æ³•å­˜åœ¨æ€§å¤±è´¥: {str(e)}")
E           AssertionError: æµ‹è¯•_collect_sync_patternsæ–¹æ³•å­˜åœ¨æ€§å¤±è´¥: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:85: AssertionError
----------------------------- Captured stdout call -----------------------------
â„¹ï¸ å¼€å§‹æµ‹è¯•: TestSyncConfigUIEnhancement
â„¹ï¸ æµ‹è¯•2: _collect_sync_patternsæ–¹æ³•å­˜åœ¨æ€§
â„¹ï¸ å®Œæˆæµ‹è¯•: TestSyncConfigUIEnhancement
_____ TestSyncConfigUIEnhancement.test_collect_sync_patterns_with_defaults _____

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_collect_sync_patterns_with_defaults>
mock_colored_print = <MagicMock name='colored_print' id='4586318576'>
mock_smart_input = <MagicMock name='smart_input' id='4586129824'>

    @patch('enhanced_config_manager.EnhancedConfigManager.smart_input')
    @patch('enhanced_config_manager.EnhancedConfigManager.colored_print')
    def test_collect_sync_patterns_with_defaults(self, mock_colored_print, mock_smart_input):
        """æµ‹è¯•6: _collect_sync_patternsæ–¹æ³•å¤„ç†é»˜è®¤å€¼"""
        log_test_output("æµ‹è¯•6: _collect_sync_patternså¤„ç†é»˜è®¤å€¼", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
>           config_manager = config_manager.main.EnhancedConfigManager()
E           UnboundLocalError: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:238: UnboundLocalError

During handling of the above exception, another exception occurred:

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_collect_sync_patterns_with_defaults>
mock_colored_print = <MagicMock name='colored_print' id='4586318576'>
mock_smart_input = <MagicMock name='smart_input' id='4586129824'>

    @patch('enhanced_config_manager.EnhancedConfigManager.smart_input')
    @patch('enhanced_config_manager.EnhancedConfigManager.colored_print')
    def test_collect_sync_patterns_with_defaults(self, mock_colored_print, mock_smart_input):
        """æµ‹è¯•6: _collect_sync_patternsæ–¹æ³•å¤„ç†é»˜è®¤å€¼"""
        log_test_output("æµ‹è¯•6: _collect_sync_patternså¤„ç†é»˜è®¤å€¼", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
            config_manager = config_manager.main.EnhancedConfigManager()
    
            # æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥ï¼ˆä¿ç•™é»˜è®¤å€¼ï¼Œä¸æ·»åŠ æ–°å€¼ï¼‰
            mock_smart_input.side_effect = [
                "*.py",  # ä¿ç•™ç¬¬ä¸€ä¸ªé»˜è®¤å€¼
                "*.js",  # ä¿ç•™ç¬¬äºŒä¸ªé»˜è®¤å€¼
                ""       # å®Œæˆé…ç½®
            ]
    
            # è°ƒç”¨_collect_sync_patternsæ–¹æ³•
            result = config_manager._collect_sync_patterns(
                "åŒ…å«æ¨¡å¼",
                defaults=['*.py', '*.js']
            )
    
            # éªŒè¯ç»“æœ
            self.assertIsInstance(result, list)
            self.assertEqual(len(result), 2)
            self.assertIn('*.py', result)
            self.assertIn('*.js', result)
    
            log_test_output("âœ… _collect_sync_patternsæ­£ç¡®å¤„ç†é»˜è®¤å€¼", "SUCCESS")
    
        except Exception as e:
>           self.fail(f"æµ‹è¯•_collect_sync_patternså¤„ç†é»˜è®¤å€¼å¤±è´¥: {str(e)}")
E           AssertionError: æµ‹è¯•_collect_sync_patternså¤„ç†é»˜è®¤å€¼å¤±è´¥: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:262: AssertionError
----------------------------- Captured stdout call -----------------------------
â„¹ï¸ å¼€å§‹æµ‹è¯•: TestSyncConfigUIEnhancement
â„¹ï¸ æµ‹è¯•6: _collect_sync_patternså¤„ç†é»˜è®¤å€¼
â„¹ï¸ å®Œæˆæµ‹è¯•: TestSyncConfigUIEnhancement
___________ TestSyncConfigUIEnhancement.test_configure_sync_disabled ___________

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_configure_sync_disabled>
mock_colored_print = <MagicMock name='colored_print' id='4425980320'>
mock_smart_input = <MagicMock name='smart_input' id='4586226544'>

    @patch('enhanced_config_manager.EnhancedConfigManager.smart_input')
    @patch('enhanced_config_manager.EnhancedConfigManager.colored_print')
    def test_configure_sync_disabled(self, mock_colored_print, mock_smart_input):
        """æµ‹è¯•3: ç”¨æˆ·é€‰æ‹©ä¸å¯ç”¨è‡ªåŠ¨åŒæ­¥"""
        log_test_output("æµ‹è¯•3: ç”¨æˆ·é€‰æ‹©ä¸å¯ç”¨è‡ªåŠ¨åŒæ­¥", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
>           config_manager = config_manager.main.EnhancedConfigManager()
E           UnboundLocalError: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:97: UnboundLocalError

During handling of the above exception, another exception occurred:

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_configure_sync_disabled>
mock_colored_print = <MagicMock name='colored_print' id='4425980320'>
mock_smart_input = <MagicMock name='smart_input' id='4586226544'>

    @patch('enhanced_config_manager.EnhancedConfigManager.smart_input')
    @patch('enhanced_config_manager.EnhancedConfigManager.colored_print')
    def test_configure_sync_disabled(self, mock_colored_print, mock_smart_input):
        """æµ‹è¯•3: ç”¨æˆ·é€‰æ‹©ä¸å¯ç”¨è‡ªåŠ¨åŒæ­¥"""
        log_test_output("æµ‹è¯•3: ç”¨æˆ·é€‰æ‹©ä¸å¯ç”¨è‡ªåŠ¨åŒæ­¥", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
            config_manager = config_manager.main.EnhancedConfigManager()
    
            # æ¨¡æ‹Ÿç”¨æˆ·é€‰æ‹©ä¸å¯ç”¨åŒæ­¥
            mock_smart_input.return_value = "2"
    
            # è°ƒç”¨_configure_syncæ–¹æ³•
            result = config_manager._configure_sync()
    
            # éªŒè¯ç»“æœ
            self.assertIsNone(result)
    
            # éªŒè¯smart_inputè¢«è°ƒç”¨
            mock_smart_input.assert_called_once()
    
            log_test_output("âœ… ç”¨æˆ·é€‰æ‹©ä¸å¯ç”¨åŒæ­¥æ—¶æ­£ç¡®è¿”å›None", "SUCCESS")
    
        except Exception as e:
>           self.fail(f"æµ‹è¯•ç”¨æˆ·é€‰æ‹©ä¸å¯ç”¨åŒæ­¥å¤±è´¥: {str(e)}")
E           AssertionError: æµ‹è¯•ç”¨æˆ·é€‰æ‹©ä¸å¯ç”¨åŒæ­¥å¤±è´¥: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:114: AssertionError
----------------------------- Captured stdout call -----------------------------
â„¹ï¸ å¼€å§‹æµ‹è¯•: TestSyncConfigUIEnhancement
â„¹ï¸ æµ‹è¯•3: ç”¨æˆ·é€‰æ‹©ä¸å¯ç”¨è‡ªåŠ¨åŒæ­¥
â„¹ï¸ å®Œæˆæµ‹è¯•: TestSyncConfigUIEnhancement
_____ TestSyncConfigUIEnhancement.test_configure_sync_enabled_full_config ______

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_configure_sync_enabled_full_config>
mock_collect_patterns = <MagicMock name='_collect_sync_patterns' id='4586267360'>
mock_colored_print = <MagicMock name='colored_print' id='4586387344'>
mock_smart_input = <MagicMock name='smart_input' id='4586271984'>

    @patch('enhanced_config_manager.EnhancedConfigManager.smart_input')
    @patch('enhanced_config_manager.EnhancedConfigManager.colored_print')
    @patch('enhanced_config_manager.EnhancedConfigManager._collect_sync_patterns')
    def test_configure_sync_enabled_full_config(self, mock_collect_patterns, mock_colored_print, mock_smart_input):
        """æµ‹è¯•4: ç”¨æˆ·å¯ç”¨è‡ªåŠ¨åŒæ­¥å¹¶å®Œæ•´é…ç½®"""
        log_test_output("æµ‹è¯•4: ç”¨æˆ·å¯ç”¨è‡ªåŠ¨åŒæ­¥å¹¶å®Œæ•´é…ç½®", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
>           config_manager = config_manager.main.EnhancedConfigManager()
E           UnboundLocalError: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:127: UnboundLocalError

During handling of the above exception, another exception occurred:

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_configure_sync_enabled_full_config>
mock_collect_patterns = <MagicMock name='_collect_sync_patterns' id='4586267360'>
mock_colored_print = <MagicMock name='colored_print' id='4586387344'>
mock_smart_input = <MagicMock name='smart_input' id='4586271984'>

    @patch('enhanced_config_manager.EnhancedConfigManager.smart_input')
    @patch('enhanced_config_manager.EnhancedConfigManager.colored_print')
    @patch('enhanced_config_manager.EnhancedConfigManager._collect_sync_patterns')
    def test_configure_sync_enabled_full_config(self, mock_collect_patterns, mock_colored_print, mock_smart_input):
        """æµ‹è¯•4: ç”¨æˆ·å¯ç”¨è‡ªåŠ¨åŒæ­¥å¹¶å®Œæ•´é…ç½®"""
        log_test_output("æµ‹è¯•4: ç”¨æˆ·å¯ç”¨è‡ªåŠ¨åŒæ­¥å¹¶å®Œæ•´é…ç½®", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
            config_manager = config_manager.main.EnhancedConfigManager()
    
            # æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥åºåˆ—
            mock_smart_input.side_effect = [
                "1",  # å¯ç”¨è‡ªåŠ¨åŒæ­¥
                "/home/Code",  # è¿œç¨‹å·¥ä½œç›®å½•
                "8021",  # FTPç«¯å£
                "ftpuser",  # FTPç”¨æˆ·å
                "mypassword",  # FTPå¯†ç 
                "/local/workspace"  # æœ¬åœ°å·¥ä½œç›®å½•
            ]
    
            # æ¨¡æ‹Ÿcollect_sync_patternsè¿”å›å€¼
            mock_collect_patterns.side_effect = [
                ['*.py', '*.js', '*.md'],  # åŒ…å«æ¨¡å¼
                ['*.pyc', '__pycache__', '.git']  # æ’é™¤æ¨¡å¼
            ]
    
            # è°ƒç”¨_configure_syncæ–¹æ³•
            result = config_manager._configure_sync()
    
            # éªŒè¯ç»“æœ
            self.assertIsNotNone(result)
            self.assertIsInstance(result, dict)
            self.assertTrue(result.get('enabled'))
            self.assertEqual(result.get('remote_workspace'), '/home/Code')
            self.assertEqual(result.get('ftp_port'), '8021')
            self.assertEqual(result.get('ftp_user'), 'ftpuser')
            self.assertEqual(result.get('ftp_password'), 'mypassword')
            self.assertEqual(result.get('local_workspace'), '/local/workspace')
            self.assertEqual(result.get('include_patterns'), ['*.py', '*.js', '*.md'])
            self.assertEqual(result.get('exclude_patterns'), ['*.pyc', '__pycache__', '.git'])
    
            # éªŒè¯smart_inputè¢«æ­£ç¡®è°ƒç”¨
            self.assertEqual(mock_smart_input.call_count, 6)
    
            # éªŒè¯_collect_sync_patternsè¢«è°ƒç”¨ä¸¤æ¬¡
            self.assertEqual(mock_collect_patterns.call_count, 2)
    
            log_test_output("âœ… ç”¨æˆ·å¯ç”¨åŒæ­¥æ—¶æ­£ç¡®æ”¶é›†æ‰€æœ‰é…ç½®", "SUCCESS")
    
        except Exception as e:
>           self.fail(f"æµ‹è¯•ç”¨æˆ·å¯ç”¨åŒæ­¥é…ç½®å¤±è´¥: {str(e)}")
E           AssertionError: æµ‹è¯•ç”¨æˆ·å¯ç”¨åŒæ­¥é…ç½®å¤±è´¥: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:169: AssertionError
----------------------------- Captured stdout call -----------------------------
â„¹ï¸ å¼€å§‹æµ‹è¯•: TestSyncConfigUIEnhancement
â„¹ï¸ æµ‹è¯•4: ç”¨æˆ·å¯ç”¨è‡ªåŠ¨åŒæ­¥å¹¶å®Œæ•´é…ç½®
â„¹ï¸ å®Œæˆæµ‹è¯•: TestSyncConfigUIEnhancement
________ TestSyncConfigUIEnhancement.test_configure_sync_method_exists _________

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_configure_sync_method_exists>

    def test_configure_sync_method_exists(self):
        """æµ‹è¯•1: _configure_syncæ–¹æ³•å­˜åœ¨ä¸”å¯è°ƒç”¨"""
        log_test_output("æµ‹è¯•1: _configure_syncæ–¹æ³•å­˜åœ¨æ€§", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
>           config_manager = config_manager.main.EnhancedConfigManager()
E           UnboundLocalError: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:53: UnboundLocalError

During handling of the above exception, another exception occurred:

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_configure_sync_method_exists>

    def test_configure_sync_method_exists(self):
        """æµ‹è¯•1: _configure_syncæ–¹æ³•å­˜åœ¨ä¸”å¯è°ƒç”¨"""
        log_test_output("æµ‹è¯•1: _configure_syncæ–¹æ³•å­˜åœ¨æ€§", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
            config_manager = config_manager.main.EnhancedConfigManager()
    
            # éªŒè¯æ–¹æ³•å­˜åœ¨
            self.assertTrue(hasattr(config_manager, '_configure_sync'))
            self.assertTrue(callable(getattr(config_manager, '_configure_sync')))
    
            log_test_output("âœ… _configure_syncæ–¹æ³•å­˜åœ¨ä¸”å¯è°ƒç”¨", "SUCCESS")
    
        except ImportError as e:
            self.fail(f"æ— æ³•å¯¼å…¥EnhancedConfigManager: {str(e)}")
        except Exception as e:
>           self.fail(f"æµ‹è¯•_configure_syncæ–¹æ³•å­˜åœ¨æ€§å¤±è´¥: {str(e)}")
E           AssertionError: æµ‹è¯•_configure_syncæ–¹æ³•å­˜åœ¨æ€§å¤±è´¥: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:64: AssertionError
----------------------------- Captured stdout call -----------------------------
â„¹ï¸ å¼€å§‹æµ‹è¯•: TestSyncConfigUIEnhancement
â„¹ï¸ æµ‹è¯•1: _configure_syncæ–¹æ³•å­˜åœ¨æ€§
â„¹ï¸ å®Œæˆæµ‹è¯•: TestSyncConfigUIEnhancement
________ TestSyncConfigUIEnhancement.test_configure_sync_with_defaults _________

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_configure_sync_with_defaults>
mock_collect_patterns = <MagicMock name='_collect_sync_patterns' id='4586268800'>
mock_colored_print = <MagicMock name='colored_print' id='4586333712'>
mock_smart_input = <MagicMock name='smart_input' id='4586199696'>

    @patch('enhanced_config_manager.EnhancedConfigManager.smart_input')
    @patch('enhanced_config_manager.EnhancedConfigManager.colored_print')
    @patch('enhanced_config_manager.EnhancedConfigManager._collect_sync_patterns')
    def test_configure_sync_with_defaults(self, mock_collect_patterns, mock_colored_print, mock_smart_input):
        """æµ‹è¯•5: ä½¿ç”¨é»˜è®¤å€¼é…ç½®è‡ªåŠ¨åŒæ­¥"""
        log_test_output("æµ‹è¯•5: ä½¿ç”¨é»˜è®¤å€¼é…ç½®è‡ªåŠ¨åŒæ­¥", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
>           config_manager = config_manager.main.EnhancedConfigManager()
E           UnboundLocalError: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:182: UnboundLocalError

During handling of the above exception, another exception occurred:

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_configure_sync_with_defaults>
mock_collect_patterns = <MagicMock name='_collect_sync_patterns' id='4586268800'>
mock_colored_print = <MagicMock name='colored_print' id='4586333712'>
mock_smart_input = <MagicMock name='smart_input' id='4586199696'>

    @patch('enhanced_config_manager.EnhancedConfigManager.smart_input')
    @patch('enhanced_config_manager.EnhancedConfigManager.colored_print')
    @patch('enhanced_config_manager.EnhancedConfigManager._collect_sync_patterns')
    def test_configure_sync_with_defaults(self, mock_collect_patterns, mock_colored_print, mock_smart_input):
        """æµ‹è¯•5: ä½¿ç”¨é»˜è®¤å€¼é…ç½®è‡ªåŠ¨åŒæ­¥"""
        log_test_output("æµ‹è¯•5: ä½¿ç”¨é»˜è®¤å€¼é…ç½®è‡ªåŠ¨åŒæ­¥", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
            config_manager = config_manager.main.EnhancedConfigManager()
    
            # å‡†å¤‡é»˜è®¤é…ç½®
            defaults = {
                'enabled': True,
                'remote_workspace': '/test/workspace',
                'ftp_port': 9021,
                'ftp_user': 'testuser',
                'ftp_password': 'testpassword',
                'local_workspace': '/test/local',
                'include_patterns': ['*.test'],
                'exclude_patterns': ['*.temp']
            }
    
            # æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥åºåˆ—ï¼ˆä½¿ç”¨é»˜è®¤å€¼ï¼‰
            mock_smart_input.side_effect = [
                "1",  # å¯ç”¨è‡ªåŠ¨åŒæ­¥
                "/test/workspace",  # è¿œç¨‹å·¥ä½œç›®å½•ï¼ˆä½¿ç”¨é»˜è®¤å€¼ï¼‰
                "9021",  # FTPç«¯å£ï¼ˆä½¿ç”¨é»˜è®¤å€¼ï¼‰
                "testuser",  # FTPç”¨æˆ·åï¼ˆä½¿ç”¨é»˜è®¤å€¼ï¼‰
                "testpassword",  # FTPå¯†ç ï¼ˆä½¿ç”¨é»˜è®¤å€¼ï¼‰
                "/test/local"  # æœ¬åœ°å·¥ä½œç›®å½•ï¼ˆä½¿ç”¨é»˜è®¤å€¼ï¼‰
            ]
    
            # æ¨¡æ‹Ÿcollect_sync_patternsè¿”å›é»˜è®¤å€¼
            mock_collect_patterns.side_effect = [
                ['*.test'],  # åŒ…å«æ¨¡å¼
                ['*.temp']   # æ’é™¤æ¨¡å¼
            ]
    
            # è°ƒç”¨_configure_syncæ–¹æ³•
            result = config_manager._configure_sync(defaults)
    
            # éªŒè¯ç»“æœ
            self.assertIsNotNone(result)
            self.assertEqual(result.get('remote_workspace'), '/test/workspace')
            self.assertEqual(result.get('ftp_port'), '9021')
            self.assertEqual(result.get('ftp_user'), 'testuser')
            self.assertEqual(result.get('ftp_password'), 'testpassword')
            self.assertEqual(result.get('local_workspace'), '/test/local')
    
            log_test_output("âœ… é»˜è®¤å€¼é…ç½®æ­£ç¡®åº”ç”¨", "SUCCESS")
    
        except Exception as e:
>           self.fail(f"æµ‹è¯•é»˜è®¤å€¼é…ç½®å¤±è´¥: {str(e)}")
E           AssertionError: æµ‹è¯•é»˜è®¤å€¼é…ç½®å¤±è´¥: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:226: AssertionError
----------------------------- Captured stdout call -----------------------------
â„¹ï¸ å¼€å§‹æµ‹è¯•: TestSyncConfigUIEnhancement
â„¹ï¸ æµ‹è¯•5: ä½¿ç”¨é»˜è®¤å€¼é…ç½®è‡ªåŠ¨åŒæ­¥
â„¹ï¸ å®Œæˆæµ‹è¯•: TestSyncConfigUIEnhancement
__________ TestSyncConfigUIEnhancement.test_guided_setup_integration ___________

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_guided_setup_integration>
mock_guided_setup = <MagicMock name='guided_setup' id='4623276448'>

    @patch('enhanced_config_manager.EnhancedConfigManager.guided_setup')
    def test_guided_setup_integration(self, mock_guided_setup):
        """æµ‹è¯•8: guided_setupé›†æˆè‡ªåŠ¨åŒæ­¥é…ç½®"""
        log_test_output("æµ‹è¯•8: guided_setupé›†æˆè‡ªåŠ¨åŒæ­¥é…ç½®", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
>           config_manager = config_manager.main.EnhancedConfigManager()
E           UnboundLocalError: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:311: UnboundLocalError

During handling of the above exception, another exception occurred:

self = <test_sync_config_ui_enhancement.TestSyncConfigUIEnhancement testMethod=test_guided_setup_integration>
mock_guided_setup = <MagicMock name='guided_setup' id='4623276448'>

    @patch('enhanced_config_manager.EnhancedConfigManager.guided_setup')
    def test_guided_setup_integration(self, mock_guided_setup):
        """æµ‹è¯•8: guided_setupé›†æˆè‡ªåŠ¨åŒæ­¥é…ç½®"""
        log_test_output("æµ‹è¯•8: guided_setupé›†æˆè‡ªåŠ¨åŒæ­¥é…ç½®", "INFO")
    
        try:
            from config_manager.main import EnhancedConfigManager
    
            # åˆ›å»ºé…ç½®ç®¡ç†å™¨å®ä¾‹
            config_manager = config_manager.main.EnhancedConfigManager()
    
            # æ¨¡æ‹Ÿguided_setupè¿”å›å€¼
            mock_guided_setup.return_value = ("test_server", {
                'connection_type': 'ssh',
                'host': 'test.example.com',
                'username': 'testuser',
                'docker_enabled': True,
                'docker_config': {},
                'auto_sync_enabled': True,
                'sync_config': {
                    'enabled': True,
                    'remote_workspace': '/home/Code',
                    'ftp_port': '8021',
                    'ftp_user': 'ftpuser',
                    'ftp_password': 'syncpassword'
                }
            })
    
            # è°ƒç”¨guided_setupæ–¹æ³•
            result = config_manager.guided_setup()
    
            # éªŒè¯ç»“æœ
            self.assertIsNotNone(result)
            self.assertEqual(len(result), 2)
    
            server_name, config = result
            self.assertEqual(server_name, "test_server")
            self.assertIn('sync_config', config)
            self.assertTrue(config.get('auto_sync_enabled'))
    
            log_test_output("âœ… guided_setupæ­£ç¡®é›†æˆè‡ªåŠ¨åŒæ­¥é…ç½®", "SUCCESS")
    
        except Exception as e:
>           self.fail(f"æµ‹è¯•guided_setupé›†æˆå¤±è´¥: {str(e)}")
E           AssertionError: æµ‹è¯•guided_setupé›†æˆå¤±è´¥: local variable 'config_manager' referenced before assignment

tests/tool_sync_config/test_sync_config_ui_enhancement.py:345: AssertionError
----------------------------- Captured stdout call -----------------------------
â„¹ï¸ å¼€å§‹æµ‹è¯•: TestSyncConfigUIEnhancement
â„¹ï¸ æµ‹è¯•8: guided_setupé›†æˆè‡ªåŠ¨åŒæ­¥é…ç½®
â„¹ï¸ å®Œæˆæµ‹è¯•: TestSyncConfigUIEnhancement
_ TestUpdateServerInteractiveBehavior.test_update_behavior_consistency_with_create _

self = <test_fix_update_server_interactive_behavior_20241222.TestUpdateServerInteractiveBehavior testMethod=test_update_behavior_consistency_with_create>

    def test_update_behavior_consistency_with_create(self):
        """æµ‹è¯•updateè¡Œä¸ºä¸createçš„ä¸€è‡´æ€§"""
        print("ğŸ¯ æµ‹è¯•updateè¡Œä¸ºä¸createçš„ä¸€è‡´æ€§")
    
>       with patch.object(self.config_manager, 'launch_cursor_terminal_config') as mock_launch:

tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1405: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x107cf19a0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <config_manager.main.EnhancedConfigManager object at 0x107cf1b50> does not have the attribute 'launch_cursor_terminal_config'

/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1378: AttributeError
----------------------------- Captured stdout call -----------------------------
ğŸ¯ æµ‹è¯•updateè¡Œä¸ºä¸createçš„ä¸€è‡´æ€§
_ TestUpdateServerInteractiveBehavior.test_update_server_docker_config_handling _

self = <test_fix_update_server_interactive_behavior_20241222.TestUpdateServerInteractiveBehavior testMethod=test_update_server_docker_config_handling>

    def test_update_server_docker_config_handling(self):
        """æµ‹è¯•æ›´æ–°æ—¶Dockeré…ç½®çš„å¤„ç†"""
        print("ğŸ¯ æµ‹è¯•æ›´æ–°æ—¶Dockeré…ç½®çš„å¤„ç†")
    
>       with patch.object(self.config_manager, 'launch_cursor_terminal_config') as mock_launch:

tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1405: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x1115ca040>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <config_manager.main.EnhancedConfigManager object at 0x1115ca730> does not have the attribute 'launch_cursor_terminal_config'

/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1378: AttributeError
----------------------------- Captured stdout call -----------------------------
ğŸ¯ æµ‹è¯•æ›´æ–°æ—¶Dockeré…ç½®çš„å¤„ç†
____ TestUpdateServerInteractiveBehavior.test_update_server_error_handling _____

self = <test_fix_update_server_interactive_behavior_20241222.TestUpdateServerInteractiveBehavior testMethod=test_update_server_error_handling>

    def test_update_server_error_handling(self):
        """æµ‹è¯•æ›´æ–°æ—¶çš„é”™è¯¯å¤„ç†"""
        print("ğŸ¯ æµ‹è¯•æ›´æ–°æ—¶çš„é”™è¯¯å¤„ç†")
    
        # æµ‹è¯•æœåŠ¡å™¨ä¸å­˜åœ¨çš„æƒ…å†µ
>       servers = self.config_manager.get_existing_servers()

tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config_manager.main.EnhancedConfigManager object at 0x11391e1c0>

    def get_existing_servers(self) -> dict:
>       if not self.config_path.exists(): return {}
E       AttributeError: 'str' object has no attribute 'exists'

python/config_manager/main.py:58: AttributeError
----------------------------- Captured stdout call -----------------------------
ğŸ¯ æµ‹è¯•æ›´æ–°æ—¶çš„é”™è¯¯å¤„ç†
_ TestUpdateServerInteractiveBehavior.test_update_server_launches_interactive_interface _

self = <test_fix_update_server_interactive_behavior_20241222.TestUpdateServerInteractiveBehavior testMethod=test_update_server_launches_interactive_interface>

    def test_update_server_launches_interactive_interface(self):
        """æµ‹è¯•update_server_configé»˜è®¤å¯åŠ¨äº¤äº’ç•Œé¢"""
        print("ğŸ¯ æµ‹è¯•update_server_configé»˜è®¤å¯åŠ¨äº¤äº’ç•Œé¢")
    
        # æ¨¡æ‹Ÿlaunch_cursor_terminal_configæ–¹æ³•
>       with patch.object(self.config_manager, 'launch_cursor_terminal_config') as mock_launch:

tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1405: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x107cf1b50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <config_manager.main.EnhancedConfigManager object at 0x11159f370> does not have the attribute 'launch_cursor_terminal_config'

/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1378: AttributeError
----------------------------- Captured stdout call -----------------------------
ğŸ¯ æµ‹è¯•update_server_configé»˜è®¤å¯åŠ¨äº¤äº’ç•Œé¢
_ TestUpdateServerInteractiveBehavior.test_update_server_preserves_existing_config _

self = <test_fix_update_server_interactive_behavior_20241222.TestUpdateServerInteractiveBehavior testMethod=test_update_server_preserves_existing_config>

    def test_update_server_preserves_existing_config(self):
        """æµ‹è¯•æ›´æ–°æ—¶æ­£ç¡®ä¿ç•™ç°æœ‰é…ç½®"""
        print("ğŸ¯ æµ‹è¯•æ›´æ–°æ—¶æ­£ç¡®ä¿ç•™ç°æœ‰é…ç½®")
    
>       servers = self.config_manager.get_existing_servers()

tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <config_manager.main.EnhancedConfigManager object at 0x106f90220>

    def get_existing_servers(self) -> dict:
>       if not self.config_path.exists(): return {}
E       AttributeError: 'str' object has no attribute 'exists'

python/config_manager/main.py:58: AttributeError
----------------------------- Captured stdout call -----------------------------
ğŸ¯ æµ‹è¯•æ›´æ–°æ—¶æ­£ç¡®ä¿ç•™ç°æœ‰é…ç½®
_ TestUpdateServerInteractiveBehavior.test_update_server_relay_config_handling _

self = <test_fix_update_server_interactive_behavior_20241222.TestUpdateServerInteractiveBehavior testMethod=test_update_server_relay_config_handling>

    def test_update_server_relay_config_handling(self):
        """æµ‹è¯•æ›´æ–°æ—¶Relayé…ç½®çš„å¤„ç†"""
        print("ğŸ¯ æµ‹è¯•æ›´æ–°æ—¶Relayé…ç½®çš„å¤„ç†")
    
        # åˆ›å»ºå¸¦Relayé…ç½®çš„æµ‹è¯•æœåŠ¡å™¨
        relay_config = {
            'servers': {
                'test_relay_server': {
                    'description': 'æµ‹è¯•RelayæœåŠ¡å™¨',
                    'host': 'relay.test.com',
                    'port': 22,
                    'username': 'relayuser',
                    'connection_type': 'relay',
                    'type': 'script_based',
                    'specs': {
                        'connection': {
                            'target': {
                                'host': 'target.relay.com'
                            }
                        }
                    }
                }
            }
        }
    
        # ä¿å­˜Relayé…ç½®
        with open(self.temp_config.name, 'w', encoding='utf-8') as f:
            yaml.dump(relay_config, f, default_flow_style=False, allow_unicode=True)
    
>       with patch.object(self.config_manager, 'launch_cursor_terminal_config') as mock_launch:

tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1405: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x1115bdac0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <config_manager.main.EnhancedConfigManager object at 0x1115bddf0> does not have the attribute 'launch_cursor_terminal_config'

/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/mock.py:1378: AttributeError
----------------------------- Captured stdout call -----------------------------
ğŸ¯ æµ‹è¯•æ›´æ–°æ—¶Relayé…ç½®çš„å¤„ç†
____________________ test_interactive_update_server_config _____________________

    def test_interactive_update_server_config():
        # å†™å…¥åˆå§‹é…ç½®
        with open(TEST_CONFIG_PATH, 'w', encoding='utf-8') as f:
            yaml.safe_dump(INIT_CONFIG, f, allow_unicode=True)
        # è‡ªåŠ¨åŒ–äº¤äº’
        with patch("builtins.input", side_effect=MOCK_INPUTS):
>           manager = EnhancedConfigManager(config_path=TEST_CONFIG_PATH, force_interactive=True)
E           TypeError: __init__() got an unexpected keyword argument 'force_interactive'

tests/tool_update_server_config/test_interactive_update_server_config.py:55: TypeError
________________ test_interactive_update_server_config_prefill _________________

    def test_interactive_update_server_config_prefill():
        # å†™å…¥åˆå§‹é…ç½®
        with open(TEST_CONFIG_PATH, 'w', encoding='utf-8') as f:
            yaml.safe_dump(INIT_CONFIG, f, allow_unicode=True)
        # é¢„å¡«å‚æ•°
        prefill = {
            'name': 'hg225',
            'host': '192.168.1.226',  # ä¿®æ”¹åçš„host
            'username': 'admin',
        }
        with patch("builtins.input", side_effect=MOCK_INPUTS):
>           manager = EnhancedConfigManager(config_path=TEST_CONFIG_PATH, force_interactive=True)
E           TypeError: __init__() got an unexpected keyword argument 'force_interactive'

tests/tool_update_server_config/test_interactive_update_server_config_prefill.py:60: TypeError
=============================== warnings summary ===============================
tests/tool_diagnose_connection/test_fix_parameter_error_and_ux_20240622.py:32
  /Users/xuyehua/Code/remote-terminal-mcp/tests/tool_diagnose_connection/test_fix_parameter_error_and_ux_20240622.py:32: PytestCollectionWarning: cannot collect test class 'TestParameterErrorAndUXFix' because it has a __init__ constructor (from: tests/tool_diagnose_connection/test_fix_parameter_error_and_ux_20240622.py)
    class TestParameterErrorAndUXFix:

tests/tool_execute_command/test_fix_smart_auto_switch_mode_20240622.py:33
  /Users/xuyehua/Code/remote-terminal-mcp/tests/tool_execute_command/test_fix_smart_auto_switch_mode_20240622.py:33: PytestCollectionWarning: cannot collect test class 'TestSmartAutoSwitchMode' because it has a __init__ constructor (from: tests/tool_execute_command/test_fix_smart_auto_switch_mode_20240622.py)
    class TestSmartAutoSwitchMode:

tests/tool_disconnect_server/test_fix_terminal_cleanup_bug_20241222.py::TestTerminalCleanupBugFix::test_cleanup_disabled_behavior
  /Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/case.py:550: RuntimeWarning: coroutine 'TestTerminalCleanupBugFix.test_cleanup_disabled_behavior' was never awaited
    method()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/tool_disconnect_server/test_fix_terminal_cleanup_bug_20241222.py::TestTerminalCleanupBugFix::test_cleanup_terminals_method
  /Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/case.py:550: RuntimeWarning: coroutine 'TestTerminalCleanupBugFix.test_cleanup_terminals_method' was never awaited
    method()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/tool_disconnect_server/test_fix_terminal_cleanup_bug_20241222.py::TestTerminalCleanupBugFix::test_force_cleanup_terminals_method
  /Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/unittest/case.py:550: RuntimeWarning: coroutine 'TestTerminalCleanupBugFix.test_force_cleanup_terminals_method' was never awaited
    method()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/tool_add_server_config/test_fix_save_config_parameter_mismatch_20250615.py::TestSaveConfigParameterFix::test_regression_server_deletion_scenario
FAILED tests/tool_add_server_config/test_fix_save_config_parameter_mismatch_20250615.py::TestSaveConfigParameterFix::test_save_config_parameter_name_consistency
FAILED tests/tool_add_server_config/test_fix_save_config_parameter_mismatch_20250615.py::TestSaveConfigParameterFix::test_save_config_with_merge_false
FAILED tests/tool_add_server_config/test_fix_save_config_parameter_mismatch_20250615.py::TestSaveConfigParameterFix::test_save_config_with_merge_parameter
FAILED tests/tool_add_server_config/test_interactive_create_server_config.py::test_interactive_create_server_config
FAILED tests/tool_add_server_config/test_interactive_create_server_config_prefill.py::test_interactive_create_server_config_prefill
FAILED tests/tool_delete_server_config/test_fix_config_ux_and_prefill_bug.py::TestConfigUXPrefillFix::test_guided_setup_for_relay_server
FAILED tests/tool_delete_server_config/test_fix_config_ux_and_prefill_bug.py::TestConfigUXPrefillFix::test_update_relay_server_with_prefill_issues
FAILED tests/tool_execute_command/test_fix_example_mcp_testing_20240622.py::TestMCPToolingFramework::test_reproduce_original_issue
FAILED tests/tool_execute_command/test_fix_example_mcp_testing_20240622.py::TestMCPToolingFramework::test_integration_with_other_components
FAILED tests/tool_execute_command/test_fix_mcp_restart_and_new_code_loading_20241222.py::TestMCPRestartAndNewCodeLoading::test_new_update_server_config_logic_loading
FAILED tests/tool_get_server_status/test_fix_quality_assurance_rules_20240622.py::QualityAssuranceRulesTest::test_regression_directory_structure
FAILED tests/tool_get_server_status/test_fix_quality_assurance_rules_20240622.py::QualityAssuranceRulesTest::test_regression_test_naming_convention
FAILED tests/tool_list_servers/test_mcp_silent_config_regression.py::TestMCPSilentConfigRegression::test_constructor_without_force_interactive
FAILED tests/tool_list_servers/test_mcp_silent_config_regression.py::TestMCPSilentConfigRegression::test_mcp_silent_setup_auto_defaults
FAILED tests/tool_list_servers/test_mcp_silent_config_regression.py::TestMCPSilentConfigRegression::test_mcp_silent_setup_basic
FAILED tests/tool_list_servers/test_mcp_silent_config_regression.py::TestMCPSilentConfigRegression::test_mcp_silent_setup_validation
FAILED tests/tool_list_servers/test_mcp_silent_config_regression.py::TestMCPSilentConfigRegression::test_smart_input_detailed_error_messages
FAILED tests/tool_sync_config/test_sync_config_ui_enhancement.py::TestSyncConfigUIEnhancement::test_collect_sync_patterns_add_new
FAILED tests/tool_sync_config/test_sync_config_ui_enhancement.py::TestSyncConfigUIEnhancement::test_collect_sync_patterns_method_exists
FAILED tests/tool_sync_config/test_sync_config_ui_enhancement.py::TestSyncConfigUIEnhancement::test_collect_sync_patterns_with_defaults
FAILED tests/tool_sync_config/test_sync_config_ui_enhancement.py::TestSyncConfigUIEnhancement::test_configure_sync_disabled
FAILED tests/tool_sync_config/test_sync_config_ui_enhancement.py::TestSyncConfigUIEnhancement::test_configure_sync_enabled_full_config
FAILED tests/tool_sync_config/test_sync_config_ui_enhancement.py::TestSyncConfigUIEnhancement::test_configure_sync_method_exists
FAILED tests/tool_sync_config/test_sync_config_ui_enhancement.py::TestSyncConfigUIEnhancement::test_configure_sync_with_defaults
FAILED tests/tool_sync_config/test_sync_config_ui_enhancement.py::TestSyncConfigUIEnhancement::test_guided_setup_integration
FAILED tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py::TestUpdateServerInteractiveBehavior::test_update_behavior_consistency_with_create
FAILED tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py::TestUpdateServerInteractiveBehavior::test_update_server_docker_config_handling
FAILED tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py::TestUpdateServerInteractiveBehavior::test_update_server_error_handling
FAILED tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py::TestUpdateServerInteractiveBehavior::test_update_server_launches_interactive_interface
FAILED tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py::TestUpdateServerInteractiveBehavior::test_update_server_preserves_existing_config
FAILED tests/tool_update_server_config/test_fix_update_server_interactive_behavior_20241222.py::TestUpdateServerInteractiveBehavior::test_update_server_relay_config_handling
FAILED tests/tool_update_server_config/test_interactive_update_server_config.py::test_interactive_update_server_config
FAILED tests/tool_update_server_config/test_interactive_update_server_config_prefill.py::test_interactive_update_server_config_prefill
============ 34 failed, 49 passed, 2 skipped, 5 warnings in 36.79s =============
